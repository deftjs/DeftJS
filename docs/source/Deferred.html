<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.4.0
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

<span id='Deft-promise-Deferred'>/**
</span>* A Deferred manages the state of an asynchronous process that will eventually be exposed to external code via a Deft.promise.Promise.
*/

Ext.define('Deft.promise.Deferred', {
  alternateClassName: ['Deft.Deferred'],
  requires: ['Deft.log.Logger', 'Deft.promise.Promise'],
<span id='Deft-promise-Deferred-property-id'>  id: null,
</span><span id='Deft-promise-Deferred-method-constructor'>  constructor: function(config) {
</span>    if (config == null) {
      config = {};
    }
    this.id = config.id;
    this.state = 'pending';
    this.progress = void 0;
    this.value = void 0;
    this.progressCallbacks = [];
    this.successCallbacks = [];
    this.failureCallbacks = [];
    this.cancelCallbacks = [];
    this.promise = Ext.create('Deft.Promise', {
      id: this.id ? &quot;of &quot; + this.id : null,
      deferred: this
    });
    return this;
  },
<span id='Deft-promise-Deferred-method-then'>  /**
</span>  	* Returns a new {@link Deft.promise.Promise} with the specified callbacks registered to be called when this {@link Deft.promise.Deferred} is resolved, rejected, updated or cancelled.
  */

  then: function(callbacks) {
    var callback, cancelCallback, deferred, failureCallback, progressCallback, scope, successCallback, _i, _len, _ref;
    if (Ext.isObject(callbacks)) {
      successCallback = callbacks.success, failureCallback = callbacks.failure, progressCallback = callbacks.progress, cancelCallback = callbacks.cancel, scope = callbacks.scope;
    } else {
      successCallback = arguments[0], failureCallback = arguments[1], progressCallback = arguments[2], cancelCallback = arguments[3], scope = arguments[4];
    }
    _ref = [successCallback, failureCallback, progressCallback, cancelCallback];
    for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
      callback = _ref[_i];
      if (!(Ext.isFunction(callback) || callback === null || callback === void 0)) {
        Ext.Error.raise({
          msg: &quot;Error while registering callback with &quot; + this + &quot;: a non-function specified.&quot;
        });
      }
    }
    deferred = Ext.create('Deft.promise.Deferred', {
      id: &quot;transformed result of &quot; + this
    });
    this.register(this.wrapCallback(deferred, successCallback, scope, 'success', 'resolve'), this.successCallbacks, 'resolved', this.value);
    this.register(this.wrapCallback(deferred, failureCallback, scope, 'failure', 'reject'), this.failureCallbacks, 'rejected', this.value);
    this.register(this.wrapCallback(deferred, cancelCallback, scope, 'cancel', 'cancel'), this.cancelCallbacks, 'cancelled', this.value);
    this.register(this.wrapProgressCallback(deferred, progressCallback, scope), this.progressCallbacks, 'pending', this.progress);
    Deft.Logger.log(&quot;Returning &quot; + (deferred.getPromise()) + &quot;.&quot;);
    return deferred.getPromise();
  },
<span id='Deft-promise-Deferred-method-otherwise'>  /**
</span>  	* Returns a new {@link Deft.promise.Promise} with the specified callback registered to be called when this {@link Deft.promise.Deferred} is rejected.
  */

  otherwise: function(callback, scope) {
    var _ref;
    if (Ext.isObject(callback)) {
      _ref = callback, callback = _ref.fn, scope = _ref.scope;
    }
    return this.then({
      failure: callback,
      scope: scope
    });
  },
<span id='Deft-promise-Deferred-method-always'>  /**
</span>  	* Returns a new {@link Deft.promise.Promise} with the specified callback registered to be called when this {@link Deft.promise.Deferred} is either resolved, rejected, or cancelled.
  */

  always: function(callback, scope) {
    var _ref;
    if (Ext.isObject(callback)) {
      _ref = callback, callback = _ref.fn, scope = _ref.scope;
    }
    return this.then({
      success: callback,
      failure: callback,
      cancel: callback,
      scope: scope
    });
  },
<span id='Deft-promise-Deferred-method-update'>  /**
</span>  	* Update progress for this {@link Deft.promise.Deferred} and notify relevant callbacks.
  */

  update: function(progress) {
    Deft.Logger.log(&quot;&quot; + this + &quot; updated with progress: &quot; + progress);
    if (this.state === 'pending') {
      this.progress = progress;
      this.notify(this.progressCallbacks, progress);
    } else {
      if (this.state !== 'cancelled') {
        Ext.Error.raise({
          msg: &quot;Error: this &quot; + this + &quot; has already been completed and cannot be modified.&quot;
        });
      }
    }
  },
<span id='Deft-promise-Deferred-method-resolve'>  /**
</span>  	* Resolve this {@link Deft.promise.Deferred} and notify relevant callbacks.
  */

  resolve: function(value) {
    Deft.Logger.log(&quot;&quot; + this + &quot; resolved with value: &quot; + value);
    this.complete('resolved', value, this.successCallbacks);
  },
<span id='Deft-promise-Deferred-method-reject'>  /**
</span>  	* Reject this {@link Deft.promise.Deferred} and notify relevant callbacks.
  */

  reject: function(error) {
    Deft.Logger.log(&quot;&quot; + this + &quot; rejected with error: &quot; + error);
    this.complete('rejected', error, this.failureCallbacks);
  },
<span id='Deft-promise-Deferred-method-cancel'>  /**
</span>  	* Cancel this {@link Deft.promise.Deferred} and notify relevant callbacks.
  */

  cancel: function(reason) {
    Deft.Logger.log(&quot;&quot; + this + &quot; cancelled with reason: &quot; + reason);
    this.complete('cancelled', reason, this.cancelCallbacks);
  },
<span id='Deft-promise-Deferred-method-getPromise'>  /**
</span>  	* Get this {@link Deft.promise.Deferred}'s associated {@link Deft.promise.Promise}.
  */

  getPromise: function() {
    return this.promise;
  },
<span id='Deft-promise-Deferred-method-getState'>  /**
</span>  	* Get this {@link Deft.promise.Deferred}'s current state.
  */

  getState: function() {
    return this.state;
  },
<span id='Deft-promise-Deferred-method-toString'>  /**
</span>  	* Returns a text representation of this {@link Deft.promise.Deferred}, including its optional id.
  */

  toString: function() {
    if (this.id != null) {
      return &quot;Deferred &quot; + this.id;
    }
    return &quot;Deferred&quot;;
  },
<span id='Deft-promise-Deferred-method-wrapCallback'>  /**
</span>  	* Wraps a success, failure or cancel callback.
  	* @private
  */

  wrapCallback: function(deferred, callback, scope, callbackType, action) {
    var self;
    self = this;
    if (callback != null) {
      Deft.Logger.log(&quot;Registering &quot; + callbackType + &quot; callback for &quot; + self + &quot;.&quot;);
    }
    return function(value) {
      var result;
      if (Ext.isFunction(callback)) {
        try {
          Deft.Logger.log(&quot;Calling &quot; + callbackType + &quot; callback registered for &quot; + self + &quot;.&quot;);
          result = callback.call(scope, value);
          if (result instanceof Ext.ClassManager.get('Deft.promise.Promise') || result instanceof Ext.ClassManager.get('Deft.promise.Deferred')) {
            Deft.Logger.log(&quot;&quot; + (deferred.getPromise()) + &quot; will be completed based on the &quot; + result + &quot; returned by the &quot; + callbackType + &quot; callback.&quot;);
            result.then(Ext.bind(deferred.resolve, deferred), Ext.bind(deferred.reject, deferred), Ext.bind(deferred.update, deferred), Ext.bind(deferred.cancel, deferred));
          } else {
            Deft.Logger.log(&quot;&quot; + (deferred.getPromise()) + &quot; resolved with the value returned by the &quot; + callbackType + &quot; callback: &quot; + result + &quot;.&quot;);
            deferred.resolve(result);
          }
        } catch (error) {
          if (Ext.Array.contains(['RangeError', 'ReferenceError', 'SyntaxError', 'TypeError'], error.name)) {
            Deft.Logger.error(&quot;Error: &quot; + callbackType + &quot; callback for &quot; + self + &quot; threw: &quot; + (error.stack != null ? error.stack : error));
          } else {
            Deft.Logger.log(&quot;&quot; + (deferred.getPromise()) + &quot; rejected with the Error returned by the &quot; + callbackType + &quot; callback: &quot; + error);
          }
          deferred.reject(error);
        }
      } else {
        Deft.Logger.log(&quot;&quot; + (deferred.getPromise()) + &quot; resolved with the value: &quot; + value + &quot;.&quot;);
        deferred[action](value);
      }
    };
  },
<span id='Deft-promise-Deferred-method-wrapProgressCallback'>  /**
</span>  	* Wraps a success, failure or cancel callback.
  	* @private
  */

  wrapProgressCallback: function(deferred, callback, scope) {
    var self;
    self = this;
    if (callback != null) {
      Deft.Logger.log(&quot;Registering progress callback for &quot; + self + &quot;.&quot;);
    }
    return function(value) {
      var result;
      if (Ext.isFunction(callback)) {
        try {
          Deft.Logger.log(&quot;Calling progress callback registered for &quot; + self + &quot;.&quot;);
          result = callback.call(scope, value);
          Deft.Logger.log(&quot;&quot; + (deferred.getPromise()) + &quot; updated with progress returned by the progress callback: &quot; + result + &quot;.&quot;);
          deferred.update(result);
        } catch (error) {
          Deft.Logger.error(&quot;Error: progress callback registered for &quot; + self + &quot; threw: &quot; + (error.stack != null ? error.stack : error));
        }
      } else {
        Deft.Logger.log(&quot;&quot; + (deferred.getPromise()) + &quot; updated with progress: &quot; + value);
        deferred.update(value);
      }
    };
  },
<span id='Deft-promise-Deferred-method-register'>  /**
</span>  	* Register a callback for this {@link Deft.promise.Deferred} for the specified callbacks and state, immediately notifying with the specified value (if applicable).
  	* @private
  */

  register: function(callback, callbacks, state, value) {
    if (Ext.isFunction(callback)) {
      if (this.state === 'pending') {
        callbacks.push(callback);
        if (this.state === state &amp;&amp; value !== void 0) {
          this.notify([callback], value);
        }
      } else {
        if (this.state === state) {
          this.notify([callback], value);
        }
      }
    }
  },
<span id='Deft-promise-Deferred-method-complete'>  /**
</span>  	* Complete this {@link Deft.promise.Deferred} with the specified state and value.
  	* @private
  */

  complete: function(state, value, callbacks) {
    if (this.state === 'pending') {
      this.state = state;
      this.value = value;
      this.notify(callbacks, value);
      this.releaseCallbacks();
    } else {
      if (this.state !== 'cancelled') {
        Ext.Error.raise({
          msg: &quot;Error: this &quot; + this + &quot; has already been completed and cannot be modified.&quot;
        });
      }
    }
  },
<span id='Deft-promise-Deferred-method-notify'>  /**
</span>  	* Notify the specified callbacks with the specified value.
  	* @private
  */

  notify: function(callbacks, value) {
    var callback, _i, _len;
    for (_i = 0, _len = callbacks.length; _i &lt; _len; _i++) {
      callback = callbacks[_i];
      callback(value);
    }
  },
<span id='Deft-promise-Deferred-method-releaseCallbacks'>  /**
</span>  	* Release references to all callbacks registered with this {@link Deft.promise.Deferred}.
  	* @private
  */

  releaseCallbacks: function() {
    this.progressCallbacks = null;
    this.successCallbacks = null;
    this.failureCallbacks = null;
    this.cancelCallbacks = null;
  }
});
</pre>
</body>
</html>
