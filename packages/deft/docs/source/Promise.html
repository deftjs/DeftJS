<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">// Generated by CoffeeScript 1.6.2
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).

Promise.when(), all(), any(), some(), map(), reduce(), delay() and timeout()
methods adapted from: [when.js](https://github.com/cujojs/when)
Copyright (c) B Cavalier &amp; J Hann
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/*
Promises represent a future value; i.e., a value that may not yet be available.

A Promise's then() method is used to specify onFulfilled and onRejected 
callbacks that will be notified when the future value becomes available. Those 
callbacks can subsequently transform the value that was resolved or the reason 
that was rejected. Each call to then() returns a new Promise of that 
transformed value; i.e., a Promise that is resolved with the callback return 
value or rejected with any error thrown by the callback.
*/
Ext.define('Deft.promise.Promise', {
  alternateClassName: ['Deft.Promise'],
  requires: ['Deft.promise.Resolver'],
  statics: {
<span id='global-method-when'>    /**
</span>    		* Returns a new {@link Deft.promise.Promise} that:
    		* - resolves immediately for the specified value, or
    		* - resolves or rejects when the specified {@link Deft.promise.Promise} is
    		* resolved or rejected.
    */

    when: function(promiseOrValue) {
      var deferred;

      deferred = Ext.create('Deft.promise.Deferred');
      deferred.resolve(promiseOrValue);
      return deferred.promise;
    },
<span id='global-method-isPromise'>    /**
</span>    		* Determines whether the specified value is a Promise (including third-party
    		* untrusted Promises), based on the Promises/A specification feature test.
    */

    isPromise: function(value) {
      return (value &amp;&amp; Ext.isFunction(value.then)) === true;
    },
<span id='global-method-all'>    /**
</span>    		* Returns a new {@link Deft.promise.Promise} that will only resolve
    		* once all the specified `promisesOrValues` have resolved.
    		* 
    		* The resolution value will be an Array containing the resolution
    		* value of each of the `promisesOrValues`.
    */

    all: function(promisesOrValues) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      return Deft.Promise.map(promisesOrValues, function(x) {
        return x;
      });
    },
<span id='global-method-any'>    /**
</span>    		* Initiates a competitive race, returning a new {@link Deft.promise.Promise}
    		* that will resolve when any one of the specified `promisesOrValues`
    		* have resolved, or will reject when all `promisesOrValues` have
    		* rejected or cancelled.
    		* 
    		* The resolution value will the first value of `promisesOrValues` to resolve.
    */

    any: function(promisesOrValues) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      return Deft.Promise.some(promisesOrValues, 1).then(function(array) {
        return array[0];
      }, function(error) {
        if (error.message === 'Too few Promises were resolved.') {
          throw new Error('No Promises were resolved.');
        } else {
          throw error;
        }
      });
    },
<span id='global-method-some'>    /**
</span>    		* Initiates a competitive race, returning a new {@link Deft.promise.Promise}
    		* that will resolve when `howMany` of the specified `promisesOrValues`
    		* have resolved, or will reject when it becomes impossible for
    		* `howMany` to resolve.
    		* 
    		* The resolution value will be an Array of the first `howMany` values
    		* of `promisesOrValues` to resolve.
    */

    some: function(promisesOrValues, howMany) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      if (!Ext.isNumeric(howMany) || howMany &lt;= 0) {
        throw new Error('Invalid parameter: expected a positive integer.');
      }
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var complete, deferred, index, onReject, onResolve, promiseOrValue, rejecter, remainingToReject, remainingToResolve, resolver, values, _i, _len;

        values = [];
        remainingToResolve = howMany;
        remainingToReject = (promisesOrValues.length - remainingToResolve) + 1;
        deferred = Ext.create('Deft.promise.Deferred');
        if (promisesOrValues.length &lt; howMany) {
          deferred.reject(new Error('Too few Promises were resolved.'));
        } else {
          resolver = function(value) {
            values.push(value);
            remainingToResolve--;
            if (remainingToResolve === 0) {
              complete();
              deferred.resolve(values);
            }
            return value;
          };
          rejecter = function(error) {
            remainingToReject--;
            if (remainingToReject === 0) {
              complete();
              deferred.reject(new Error('Too few Promises were resolved.'));
            }
            return error;
          };
          complete = function() {
            return resolver = rejecter = Ext.emptyFn;
          };
          onResolve = function(value) {
            return resolver(value);
          };
          onReject = function(value) {
            return rejecter(value);
          };
          for (index = _i = 0, _len = promisesOrValues.length; _i &lt; _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              Deft.Promise.when(promiseOrValue).then(onResolve, onReject);
            }
          }
        }
        return deferred.promise;
      });
    },
<span id='global-method-delay'>    /**
</span>    		* Returns a new {@link Deft.promise.Promise} that will automatically
    		* resolve with the specified Promise or value after the specified
    		* delay (in milliseconds).
    */

    delay: function(promiseOrValue, milliseconds) {
      var deferred;

      if (arguments.length === 1) {
        milliseconds = promiseOrValue;
        promiseOrValue = void 0;
      }
      milliseconds = Math.max(milliseconds, 0);
      deferred = Ext.create('Deft.promise.Deferred');
      setTimeout(function() {
        deferred.resolve(promiseOrValue);
      }, milliseconds);
      return deferred.promise;
    },
<span id='global-method-timeout'>    /**
</span>    		* Returns a new {@link Deft.promise.Promise} that will automatically
    		* reject after the specified timeout (in milliseconds) if the specified 
    		* promise has not resolved or rejected.
    */

    timeout: function(promiseOrValue, milliseconds) {
      var cancelTimeout, deferred, timeoutId;

      deferred = Ext.create('Deft.promise.Deferred');
      timeoutId = setTimeout(function() {
        if (timeoutId) {
          deferred.reject(new Error('Promise timed out.'));
        }
      }, milliseconds);
      cancelTimeout = function() {
        clearTimeout(timeoutId);
        return timeoutId = null;
      };
      Deft.Promise.when(promiseOrValue).then(function(value) {
        cancelTimeout();
        deferred.resolve(value);
      }, function(reason) {
        cancelTimeout();
        deferred.reject(reason);
      });
      return deferred.promise;
    },
<span id='global-method-memoize'>    /**
</span>    		* Returns a new function that wraps the specified function and caches
    		* the results for previously processed inputs.
    		* 
    		* Similar to `Deft.util.Function::memoize()`, except it allows for
    		* parameters that are {@link Deft.promise.Promise}s and/or values.
    */

    memoize: function(fn, scope, hashFn) {
      var memoizedFn;

      memoizedFn = Deft.util.Function.memoize(fn, scope, hashFn);
      return function() {
        return Deft.Promise.all(Ext.Array.toArray(arguments)).then(function(values) {
          return memoizedFn.apply(scope, values);
        });
      };
    },
<span id='global-method-map'>    /**
</span>    		* Traditional map function, similar to `Array.prototype.map()`, that
    		* allows input to contain promises and/or values.
    		* 
    		* The specified map function may return either a value or a promise.
    */

    map: function(promisesOrValues, mapFn) {
      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      if (!Ext.isFunction(mapFn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var deferred, index, promiseOrValue, remainingToResolve, resolve, results, _i, _len;

        remainingToResolve = promisesOrValues.length;
        results = new Array(promisesOrValues.length);
        deferred = Ext.create('Deft.promise.Deferred');
        if (!remainingToResolve) {
          deferred.resolve(results);
        } else {
          resolve = function(item, index) {
            return Deft.Promise.when(item).then(function(value) {
              return mapFn(value, index, results);
            }).then(function(value) {
              results[index] = value;
              if (!--remainingToResolve) {
                deferred.resolve(results);
              }
              return value;
            }, deferred.reject);
          };
          for (index = _i = 0, _len = promisesOrValues.length; _i &lt; _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              resolve(promisesOrValues[index], index);
            } else {
              remainingToResolve--;
            }
          }
        }
        return deferred.promise;
      });
    },
<span id='global-method-reduce'>    /**
</span>    		* Traditional reduce function, similar to `Array.reduce()`, that allows
    		* input to contain promises and/or values.
    */

    reduce: function(promisesOrValues, reduceFn, initialValue) {
      var initialValueSpecified;

      if (!(Ext.isArray(promisesOrValues) || Deft.Promise.isPromise(promisesOrValues))) {
        throw new Error('Invalid parameter: expected an Array or Promise of an Array.');
      }
      if (!Ext.isFunction(reduceFn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      initialValueSpecified = arguments.length === 3;
      return Deft.Promise.when(promisesOrValues).then(function(promisesOrValues) {
        var reduceArguments;

        reduceArguments = [
          function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
            return Deft.Promise.when(previousValueOrPromise).then(function(previousValue) {
              return Deft.Promise.when(currentValueOrPromise).then(function(currentValue) {
                return reduceFn(previousValue, currentValue, currentIndex, promisesOrValues);
              });
            });
          }
        ];
        if (initialValueSpecified) {
          reduceArguments.push(initialValue);
        }
        return Deft.Promise.reduceArray.apply(promisesOrValues, reduceArguments);
      });
    },
<span id='global-method-reduceArray'>    /**
</span>    		* Fallback implementation when Array.reduce is not available.
    		* @private
    */

    reduceArray: function(reduceFn, initialValue) {
      var args, array, index, length, reduced;

      index = 0;
      array = Object(this);
      length = array.length &gt;&gt;&gt; 0;
      args = arguments;
      if (args.length &lt;= 1) {
        while (true) {
          if (index in array) {
            reduced = array[index++];
            break;
          }
          if (++index &gt;= length) {
            throw new TypeError('Reduce of empty array with no initial value');
          }
        }
      } else {
        reduced = args[1];
      }
      while (index &lt; length) {
        if (index in array) {
          reduced = reduceFn(reduced, array[index], index, array);
        }
        index++;
      }
      return reduced;
    }
  },
  constructor: function(resolver) {
    var rethrowError;

    rethrowError = function(error) {
      Deft.util.Function.nextTick(function() {
        throw error;
      });
    };
    this.then = function(onFulfilled, onRejected, onProgress, scope) {
      var _ref;

      if (arguments.length === 1 &amp;&amp; Ext.isObject(arguments[0])) {
        _ref = arguments[0], onFulfilled = _ref.success, onRejected = _ref.failure, onProgress = _ref.progress, scope = _ref.scope;
      }
      if (scope != null) {
        if (Ext.isFunction(onFulfilled)) {
          onFulfilled = Ext.Function.bind(onFulfilled, scope);
        }
        if (Ext.isFunction(onRejected)) {
          onRejected = Ext.Function.bind(onRejected, scope);
        }
        if (Ext.isFunction(onProgress)) {
          onProgress = Ext.Function.bind(onProgress, scope);
        }
      }
      return resolver.then(onFulfilled, onRejected, onProgress);
    };
    this.otherwise = function(onRejected, scope) {
      var _ref;

      if (arguments.length === 1 &amp;&amp; Ext.isObject(arguments[0])) {
        _ref = arguments[0], onRejected = _ref.fn, scope = _ref.scope;
      }
      if (scope != null) {
        onRejected = Ext.Function.bind(onRejected, scope);
      }
      return resolver.then(null, onRejected);
    };
    this.always = function(onCompleted, scope) {
      var _ref;

      if (arguments.length === 1 &amp;&amp; Ext.isObject(arguments[0])) {
        _ref = arguments[0], onCompleted = _ref.fn, scope = _ref.scope;
      }
      if (scope != null) {
        onCompleted = Ext.Function.bind(onCompleted, scope);
      }
      return resolver.then(function(value) {
        var error;

        try {
          onCompleted();
        } catch (_error) {
          error = _error;
          rethrowError(error);
        }
        return value;
      }, function(reason) {
        var error;

        try {
          onCompleted();
        } catch (_error) {
          error = _error;
          rethrowError(error);
        }
        throw reason;
      });
    };
    this.done = function() {
      resolver.then(null, rethrowError);
    };
    this.cancel = function(reason) {
      if (reason == null) {
        reason = null;
      }
      resolver.reject(new CancellationError(reason));
    };
    this.log = function(name) {
      if (name == null) {
        name = '';
      }
      return resolver.then(function(value) {
        Deft.Logger.log(&quot;&quot; + (name || 'Promise') + &quot; resolved with value: &quot; + value);
        return value;
      }, function(reason) {
        Deft.Logger.log(&quot;&quot; + (name || 'Promise') + &quot; rejected with reason: &quot; + reason);
        throw reason;
      });
    };
    return this;
  },
<span id='global-method-then'>  /**
</span>  	* Attaches callbacks that will be notified when this 
  	* {@link Deft.promise.Promise}'s future value becomes available. Those
  	* callbacks can subsequently transform the value that was resolved or
  	* the reason that was rejected.
  	* 
  	* Each call to then() returns a new Promise of that transformed value;
  	* i.e., a Promise that is resolved with the callback return value or 
  	* rejected with any error thrown by the callback.
  	*
  	* @param {Function} fn Callback function to be called when resolved.
  	* @param {Function} fn Callback function to be called when rejected.
  	* @param {Function} fn Callback function to be called with progress updates.
  	* @param {Object} scope Optional scope for the callback(s).
  	* @param {Deft.promise.Promise} A Promise of the transformed future value.
  */

  then: Ext.emptyFn,
<span id='global-method-otherwise'>  /**
</span>  	* Attaches a callback that will be called if this 
  	* {@link Deft.promise.Promise} is rejected. The callbacks can 
  	* subsequently transform the reason that was rejected.
  	* 
  	* Each call to otherwise() returns a new Promise of that transformed value;
  	* i.e., a Promise that is resolved with the callback return value or 
  	* rejected with any error thrown by the callback.
  	*
  	* @param {Function} fn Callback function to be called when rejected.
  	* @param {Object} scope Optional scope for the callback.
  	* @param {Deft.promise.Promise} A Promise of the transformed future value.
  */

  otherwise: Ext.emptyFn,
<span id='global-method-always'>  /**
</span>  	* Attaches a callback to this {Deft.promise.Promise} that will be 
  	* called when it resolves or rejects. Similar to &quot;finally&quot; in 
  	* &quot;try..catch..finally&quot;.
  	*
  	* @param {Function} fn Callback function.
  	* @param {Object} scope Optional scope for the callback.
  	* @return {Deft.promise.Promise} A new &quot;pass-through&quot; Promise that 
  	* resolves with the original value or rejects with the original reason.
  */

  always: Ext.emptyFn,
<span id='global-method-done'>  /**
</span>  	* Terminates a {Deft.promise.Promise} chain, ensuring that unhandled
  	* rejections will be thrown as Errors.
  */

  done: Ext.emptyFn,
<span id='global-method-cancel'>  /**
</span>  	* Cancels this {Deft.promise.Promise} if it is still pending, triggering 
  	* a rejection with a CancellationError that will propagate to any Promises
  	* originating from this Promise.
  */

  cancel: Ext.emptyFn,
<span id='global-method-log'>  /**
</span>  	* Logs the resolution or rejection of this Promise using 
  	* {@link Deft.Logger#log}.
  	*
  	* @param {String} An optional identifier to incorporate into the 
  	* resulting log entry.
  	* @return {Deft.promise.Promise} A new &quot;pass-through&quot; Promise that 
  	* resolves with the original value or rejects with the original reason.
  */

  log: Ext.emptyFn
}, function() {
  var target;

  if (Array.prototype.reduce != null) {
    this.reduceArray = Array.prototype.reduce;
  }
  target = typeof exports !== &quot;undefined&quot; &amp;&amp; exports !== null ? exports : window;
  target.CancellationError = function(reason) {
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CancellationError);
    }
    this.name = 'Canceled';
    this.message = reason;
  };
  target.CancellationError.prototype = new Error();
  target.CancellationError.constructor = target.CancellationError;
});
</pre>
</body>
</html>
