// Generated by CoffeeScript 1.6.2
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/*
Resolvers are used internally by Deferreds and Promises to capture and notify
callbacks, process callback return values and propagate resolution or rejection
to chained Resolvers.

Developers never directly interact with a Resolver.

A Resolver captures a pair of optional onResolved and onRejected callbacks and 
has an associated Promise. That Promise delegates its then() calls to the 
Resolver's then() method, which creates a new Resolver and schedules its 
delayed addition as a chained Resolver.

Each Deferred has an associated Resolver. A Deferred delegates resolve() and 
reject() calls to that Resolver's resolve() and reject() methods. The Resolver 
processes the resolution value and rejection reason, and propagates the 
processed resolution value or rejection reason to any chained Resolvers it may 
have created in response to then() calls. Once a chained Resolver has been 
notified, it is cleared out of the set of chained Resolvers and will not be 
notified again.
@private
*/
Ext.define('Deft.promise.Resolver', {
  alternateClassName: ['Deft.Resolver'],
  requires: ['Deft.util.Function'],
  constructor: function(onResolved, onRejected, onProgress) {
    var complete, completeRejected, completeResolved, completed, completionAction, completionValue, nextTick, pendingResolvers, process, processed, propagate, schedule;

    this.promise = Ext.create('Deft.promise.Promise', this);
    pendingResolvers = [];
    processed = false;
    completed = false;
    completionAction = null;
    completionValue = null;
    if (!Ext.isFunction(onRejected)) {
      onRejected = function(error) {
        throw error;
      };
    }
    nextTick = Deft.util.Function.nextTick;
    propagate = function() {
      var pendingResolver, _i, _len;

      for (_i = 0, _len = pendingResolvers.length; _i < _len; _i++) {
        pendingResolver = pendingResolvers[_i];
        pendingResolver[completionAction](completionValue);
      }
      pendingResolvers = [];
    };
    schedule = function(pendingResolver) {
      pendingResolvers.push(pendingResolver);
      if (completed) {
        propagate();
      }
    };
    complete = function(action, value) {
      onResolved = onRejected = onProgress = null;
      completionAction = action;
      completionValue = value;
      completed = true;
      propagate();
    };
    completeResolved = function(value) {
      complete('resolve', value);
    };
    completeRejected = function(reason) {
      complete('reject', reason);
    };
    process = function(callback, value) {
      var error;

      processed = true;
      try {
        if (Ext.isFunction(callback)) {
          value = callback(value);
        }
        if (value && Ext.isFunction(value.then)) {
          value.then(completeResolved, completeRejected);
        } else {
          completeResolved(value);
        }
      } catch (_error) {
        error = _error;
        completeRejected(error);
      }
    };
    this.resolve = function(value) {
      if (!processed) {
        process(onResolved, value);
      }
    };
    this.reject = function(reason) {
      if (!processed) {
        process(onRejected, reason);
      }
    };
    this.update = function(progress) {
      var pendingResolver, _i, _len;

      if (!completed) {
        if (Ext.isFunction(onProgress)) {
          progress = onProgress(progress);
        }
        for (_i = 0, _len = pendingResolvers.length; _i < _len; _i++) {
          pendingResolver = pendingResolvers[_i];
          pendingResolver.update(progress);
        }
      }
    };
    this.then = function(onResolved, onRejected, onProgress) {
      var pendingResolver;

      if (Ext.isFunction(onResolved) || Ext.isFunction(onRejected) || Ext.isFunction(onProgress)) {
        pendingResolver = Ext.create('Deft.promise.Resolver', onResolved, onRejected, onProgress);
        nextTick(function() {
          return schedule(pendingResolver);
        });
        return pendingResolver.promise;
      }
      return this.promise;
    };
    return this;
  }
});
