// Generated by CoffeeScript 1.6.2
/*
Copyright (c) 2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/
describe('Deft.promise.Chain', function() {
  var formatValue, targetScope, verifyArgs, verifyScope;

  formatValue = function(value) {
    var formattedValues;

    if (value instanceof Deft.promise.Promise) {
      return 'Deft.Promise';
    }
    if (value instanceof Deft.promise.Deferred) {
      return 'Deft.Deferred';
    }
    if (value instanceof Ext.ClassManager.get('Ext.Base')) {
      return Ext.ClassManager.getName(value);
    }
    if (Ext.isArray(value)) {
      formattedValues = Ext.Array.map(value, formatValue);
      return "[" + (formattedValues.join(', ')) + "]";
    }
    if (Ext.isObject(value)) {
      return 'Object';
    }
    if (Ext.isString(value)) {
      return "\"" + value + "\"";
    }
    return '' + value;
  };
  targetScope = {};
  verifyScope = function(fn, scope) {
    return function() {
      expect(this).to.equal(scope);
      return fn.apply(this, arguments);
    };
  };
  verifyArgs = function(fn, args) {
    return function() {
      expect(arguments).to.deep.equal(args);
      return fn.apply(this, arguments);
    };
  };
  describe('sequence()', function() {
    var fn1, fn2, fn3;

    fn1 = sinon.spy(function() {
      expect(fn2).not.to.have.been.called;
      expect(fn3).not.to.have.been.called;
      return 1;
    });
    fn2 = sinon.spy(function() {
      expect(fn1).to.have.been.calledOnce;
      expect(fn3).not.to.have.been.called;
      return 2;
    });
    fn3 = sinon.spy(function() {
      expect(fn1).to.have.been.calledOnce;
      expect(fn2).to.have.been.calledOnce;
      return 3;
    });
    describe('returns a new Promise that will resolve with an Array of the results returned by calling the specified functions in sequence order', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Empty Array', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Empty Array with the optional scope specified', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.sequence(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Empty Array with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [];
        promise = Deft.Chain.sequence(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one function', function() {
        var fns, promise;

        fns = [fn1];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Array with one function with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope)];
        promise = Deft.Chain.sequence(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Array with one function with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args)];
        promise = Deft.Chain.sequence(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Array of two functions', function() {
        var fns, promise;

        fns = [fn1, fn2];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Array of two functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope)];
        promise = Deft.Chain.sequence(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Array of two functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args)];
        promise = Deft.Chain.sequence(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Array of three functions', function() {
        var fns, promise;

        fns = [fn1, fn2, fn3];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Array of three functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope), verifyScope(fn3, targetScope)];
        promise = Deft.Chain.sequence(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Array of three functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args), verifyArgs(verifyScope(fn3, targetScope), args)];
        promise = Deft.Chain.sequence(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the results returned by calling the specified resolved Promise of an Array of functions in sequence order', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Promise of an empty Array', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an empty Array with the optional scope specified', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an empty Array with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [];
        promise = Deft.Chain.sequence(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one function', function() {
        var fns, promise;

        fns = [fn1];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Promise of an Array with one function with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope)];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Promise of an Array with one function with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args)];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Promise of an Array of two functions', function() {
        var fns, promise;

        fns = [fn1, fn2];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Promise of an Array of two functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope)];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Promise of an Array of two functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args)];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Promise of an Array of three functions', function() {
        var fns, promise;

        fns = [fn1, fn2, fn3];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of an Array of three functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope), verifyScope(fn3, targetScope)];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of an Array of three functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args), verifyArgs(verifyScope(fn3, targetScope), args)];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns), targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will reject with the Error associated with the specified rejected Promise of an Array of functions', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Chain.sequence(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Array of functions throws an Error', function() {
      var brokenFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      brokenFn = function() {
        throw new Error('Error message');
      };
      specify('Array with one function that throws an Error', function() {
        var fns, promise;

        fns = [brokenFn];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, brokenFn];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, fn2, brokenFn];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions throws an Error', function() {
      var brokenFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      brokenFn = function() {
        throw new Error('Error message');
      };
      specify('Promise of an Array with one function that throws an Error', function() {
        var fns, promise;

        fns = [brokenFn];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with one function and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, brokenFn];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with two functions and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, fn2, brokenFn];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Array of functions returns a rejected Promise', function() {
      var rejectFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      rejectFn = function() {
        return Deft.Deferred.reject(new Error('Error message'));
      };
      specify('Array with one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [rejectFn];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, rejectFn];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, fn2, rejectFn];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions returns a rejected Promise', function() {
      var rejectFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      rejectFn = function() {
        return Deft.Deferred.reject(new Error('Error message'));
      };
      specify('Promise of an Array with one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [rejectFn];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with one function and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, rejectFn];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with two functions and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, fn2, rejectFn];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the items in the specified Array is not a function', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Array with one non-function value', function() {
        var fns, promise;

        fns = [1];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Array with one function and one non-function value', function() {
        var fns, promise;

        fns = [fn1, 1];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Array with two functions and one non-function value', function() {
        var fns, promise;

        fns = [fn1, fn2, 1];
        promise = Deft.Chain.sequence(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the items in the specified resolved Promise of an Array is not a function ', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Promise of an Array with one non-function value', function() {
        var fns, promise;

        fns = [1];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Promise of an Array with one function and one non-function value', function() {
        var fns, promise;

        fns = [fn1, 1];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Promise of an Array with two functions and one non-function value', function() {
        var fns, promise;

        fns = [fn1, fn2, 1];
        promise = Deft.Chain.sequence(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified as the first parameter', function() {
      specify('No parameters', function() {
        expect(function() {
          return Deft.Chain.sequence();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('A non-Array parameter', function() {
        expect(function() {
          return Deft.Chain.sequence(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('parallel()', function() {
    var fn1, fn2, fn3;

    fn1 = sinon.spy(function() {
      return 1;
    });
    fn2 = sinon.spy(function() {
      return 2;
    });
    fn3 = sinon.spy(function() {
      return 3;
    });
    describe('returns a new Promise that will resolve with an Array of the results returned by calling the specified functions in parallel', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Empty Array', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Empty Array with the optional scope specified', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.parallel(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Empty Array with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [];
        promise = Deft.Chain.parallel(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one function', function() {
        var fns, promise;

        fns = [fn1];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Array with one function with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope)];
        promise = Deft.Chain.parallel(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Array with one function with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args)];
        promise = Deft.Chain.parallel(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Array of two functions', function() {
        var fns, promise;

        fns = [fn1, fn2];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Array of two functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope)];
        promise = Deft.Chain.parallel(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Array of two functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args)];
        promise = Deft.Chain.parallel(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Array of three functions', function() {
        var fns, promise;

        fns = [fn1, fn2, fn3];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Array of three functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope), verifyScope(fn3, targetScope)];
        promise = Deft.Chain.parallel(fns, targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Array of three functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args), verifyArgs(verifyScope(fn3, targetScope), args)];
        promise = Deft.Chain.parallel(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the results returned by calling the specified resolved Promise of an Array of functions in parallel', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Promise of an empty Array', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an empty Array with the optional scope specified', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an empty Array with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [];
        promise = Deft.Chain.parallel(fns, targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one function', function() {
        var fns, promise;

        fns = [fn1];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Promise of an Array with one function with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope)];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Promise of an Array with one function with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args)];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1]);
      });
      specify('Promise of an Array of two functions', function() {
        var fns, promise;

        fns = [fn1, fn2];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Promise of an Array of two functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope)];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Promise of an Array of two functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args)];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2]);
      });
      specify('Promise of an Array of three functions', function() {
        var fns, promise;

        fns = [fn1, fn2, fn3];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of an Array of three functions with the optional scope specified', function() {
        var fns, promise;

        fns = [verifyScope(fn1, targetScope), verifyScope(fn2, targetScope), verifyScope(fn3, targetScope)];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of an Array of three functions with the optional scope and arguments specified', function() {
        var args, fns, promise;

        args = ['a', 'b', 'c'];
        fns = [verifyArgs(verifyScope(fn1, targetScope), args), verifyArgs(verifyScope(fn2, targetScope), args), verifyArgs(verifyScope(fn3, targetScope), args)];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns), targetScope, 'a', 'b', 'c');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will reject with the Error associated with the specified rejected Promise of an Array of functions', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Chain.parallel(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Array of functions throws an Error', function() {
      var brokenFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      brokenFn = function() {
        throw new Error('Error message');
      };
      specify('Array with one function that throws an Error', function() {
        var fns, promise;

        fns = [brokenFn];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, brokenFn];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, fn2, brokenFn];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions throws an Error', function() {
      var brokenFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      brokenFn = function() {
        throw new Error('Error message');
      };
      specify('Promise of an Array with one function that throws an Error', function() {
        var fns, promise;

        fns = [brokenFn];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with one function and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, brokenFn];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with two functions and one function that throws an Error', function() {
        var fns, promise;

        fns = [fn1, fn2, brokenFn];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Array of functions returns a rejected Promise', function() {
      var rejectFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      rejectFn = function() {
        return Deft.Deferred.reject(new Error('Error message'));
      };
      specify('Array with one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [rejectFn];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, rejectFn];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, fn2, rejectFn];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions returns a rejected Promise', function() {
      var rejectFn;

      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      rejectFn = function() {
        return Deft.Deferred.reject(new Error('Error message'));
      };
      specify('Promise of an Array with one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [rejectFn];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with one function and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, rejectFn];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with two functions and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [fn1, fn2, rejectFn];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the items in the specified Array is not a function', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Array with one non-function value', function() {
        var fns, promise;

        fns = [1];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Array with one function and one non-function value', function() {
        var fns, promise;

        fns = [fn1, 1];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Array with two functions and one non-function value', function() {
        var fns, promise;

        fns = [fn1, fn2, 1];
        promise = Deft.Chain.parallel(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the items in the specified resolved Promise of an Array is not a function ', function() {
      beforeEach(function() {
        var fn, _i, _len, _ref, _results;

        _ref = [fn1, fn2, fn3];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          fn = _ref[_i];
          _results.push(fn.reset());
        }
        return _results;
      });
      specify('Promise of an Array with one non-function value', function() {
        var fns, promise;

        fns = [1];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Promise of an Array with one function and one non-function value', function() {
        var fns, promise;

        fns = [fn1, 1];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Promise of an Array with two functions and one non-function value', function() {
        var fns, promise;

        fns = [fn1, fn2, 1];
        promise = Deft.Chain.parallel(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified as the first parameter', function() {
      specify('No parameters', function() {
        expect(function() {
          return Deft.Chain.parallel();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('A non-Array parameter', function() {
        expect(function() {
          return Deft.Chain.parallel(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('pipeline()', function() {
    var createAppenderFn;

    createAppenderFn = function(v) {
      return function(x) {
        if (x) {
          return x + v;
        } else {
          return v;
        }
      };
    };
    describe('returns a new Promise that will resolve with the result returned by calling the specified Array of functions as a pipeline', function() {
      specify('Empty Array', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(void 0);
      });
      specify('Empty Array with an initial value', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.pipeline(fns, 'initial value');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('initial value');
      });
      specify('Empty Array with an initial value and scope', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.pipeline(fns, 'initial value');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('initial value');
      });
      specify('Array with one function', function() {
        var fns, promise;

        fns = [createAppenderFn('a')];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('a');
      });
      specify('Array with one function with an initial value', function() {
        var fns, promise;

        fns = [createAppenderFn('b')];
        promise = Deft.Chain.pipeline(fns, 'a');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('ab');
      });
      specify('Array with one function with an initial value and scope', function() {
        var fns, promise;

        fns = [verifyScope(createAppenderFn('b'), targetScope)];
        promise = Deft.Chain.pipeline(fns, 'a', targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('ab');
      });
      specify('Array of two functions', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b')];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('ab');
      });
      specify('Array of two functions with an initial value', function() {
        var fns, promise;

        fns = [createAppenderFn('b'), createAppenderFn('c')];
        promise = Deft.Chain.pipeline(fns, 'a');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abc');
      });
      specify('Array of two functions with an initial value and scope', function() {
        var fns, promise;

        fns = [verifyScope(createAppenderFn('b'), targetScope), verifyScope(createAppenderFn('c'), targetScope)];
        promise = Deft.Chain.pipeline(fns, 'a', targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abc');
      });
      specify('Array of three functions', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), createAppenderFn('c')];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abc');
      });
      specify('Array of three functions with an initial value', function() {
        var fns, promise;

        fns = [createAppenderFn('b'), createAppenderFn('c'), createAppenderFn('d')];
        promise = Deft.Chain.pipeline(fns, 'a');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abcd');
      });
      specify('Array of three functions with an initial value', function() {
        var fns, promise;

        fns = [verifyScope(createAppenderFn('b'), targetScope), verifyScope(createAppenderFn('c'), targetScope), verifyScope(createAppenderFn('d'), targetScope)];
        promise = Deft.Chain.pipeline(fns, 'a', targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abcd');
      });
    });
    describe('returns a new Promise that will resolve with the result returned by calling the specified Promise of an Array of functions as a pipeline', function() {
      specify('Promise of an empty Array', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(void 0);
      });
      specify('Promise of an empty Array with an initial value', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'initial value');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('initial value');
      });
      specify('Promise of an empty Array with an initial value and scope', function() {
        var fns, promise;

        fns = [];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'initial value');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('initial value');
      });
      specify('Promise of an Array with one function', function() {
        var fns, promise;

        fns = [createAppenderFn('a')];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('a');
      });
      specify('Promise of an Array with one function with an initial value', function() {
        var fns, promise;

        fns = [createAppenderFn('b')];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'a');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('ab');
      });
      specify('Promise of an Array with one function with an initial value and scope', function() {
        var fns, promise;

        fns = [verifyScope(createAppenderFn('b'), targetScope)];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'a', targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('ab');
      });
      specify('Promise of an Array of two functions', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b')];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('ab');
      });
      specify('Promise of an Array of two functions with an initial value', function() {
        var fns, promise;

        fns = [createAppenderFn('b'), createAppenderFn('c')];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'a');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abc');
      });
      specify('Promise of an Array of two functions with an initial value and scope', function() {
        var fns, promise;

        fns = [verifyScope(createAppenderFn('b'), targetScope), verifyScope(createAppenderFn('c'), targetScope)];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'a', targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abc');
      });
      specify('Promise of an Array of three functions', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), createAppenderFn('c')];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abc');
      });
      specify('Promise of an Array of three functions with an initial value', function() {
        var fns, promise;

        fns = [createAppenderFn('b'), createAppenderFn('c'), createAppenderFn('d')];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'a');
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abcd');
      });
      specify('Promise of an Array of three functions with an initial value', function() {
        var fns, promise;

        fns = [verifyScope(createAppenderFn('b'), targetScope), verifyScope(createAppenderFn('c'), targetScope), verifyScope(createAppenderFn('d'), targetScope)];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns), 'a', targetScope);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('abcd');
      });
    });
    describe('returns a new Promise that will reject with the Error associated with the specified rejected Promise of an Array of functions', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Chain.pipeline(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Array of functions throws an Error', function() {
      var brokenFn;

      brokenFn = function() {
        throw new Error('Error message');
      };
      specify('Array with one function that throws an Error', function() {
        var fns, promise;

        fns = [brokenFn];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that throws an Error', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), brokenFn];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that throws an Error', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), brokenFn];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions throws an Error', function() {
      var brokenFn;

      brokenFn = function() {
        throw new Error('Error message');
      };
      specify('Promise of an Array with one function that throws an Error', function() {
        var fns, promise;

        fns = [brokenFn];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with one function and one function that throws an Error', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), brokenFn];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Promise of an Array with two functions and one function that throws an Error', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), brokenFn];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Array of functions returns a rejected Promise', function() {
      var rejectFn;

      rejectFn = function() {
        return Deft.Deferred.reject(new Error('Error message'));
      };
      specify('Array with one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [rejectFn];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), rejectFn];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), rejectFn];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions returns a rejected Promise', function() {
      var rejectFn;

      rejectFn = function() {
        return Deft.Deferred.reject(new Error('Error message'));
      };
      specify('Array with one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [rejectFn];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with one function and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), rejectFn];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
      specify('Array with two functions and one function that returns a rejected Promise', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), rejectFn];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Error message');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the items in the specified Array is not a function', function() {
      specify('Array with one non-function value', function() {
        var fns, promise;

        fns = [1];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Array with one function and one non-function value', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), 1];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Array with two functions and one non-function value', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), 1];
        promise = Deft.Chain.pipeline(fns);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
    });
    describe('returns a new Promise that will reject with the associated Error if any of the items in the specified resolved Promise of an Array is not a function ', function() {
      specify('Promise of an Array with one non-function value', function() {
        var fns, promise;

        fns = [1];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Promise of an Array with one function and one non-function value', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), 1];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
      specify('Promise of an Array with two functions and one non-function value', function() {
        var fns, promise;

        fns = [createAppenderFn('a'), createAppenderFn('b'), 1];
        promise = Deft.Chain.pipeline(Deft.Deferred.resolve(fns));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Invalid parameter: expected a function.');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified as the first parameter', function() {
      specify('No parameters', function() {
        expect(function() {
          return Deft.Chain.pipeline();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('A non-Array parameter', function() {
        expect(function() {
          return Deft.Chain.pipeline(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
});
