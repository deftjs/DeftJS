// Generated by CoffeeScript 1.6.2
/*
Copyright (c) 2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/
describe('Deft.promise.Promise', function() {
  var formatValue;

  formatValue = function(value) {
    var formattedValues;

    if (value instanceof Deft.promise.Promise) {
      return 'Deft.Promise';
    }
    if (value instanceof Deft.promise.Deferred) {
      return 'Deft.Deferred';
    }
    if (value instanceof Ext.ClassManager.get('Ext.Base')) {
      return Ext.ClassManager.getName(value);
    }
    if (Ext.isArray(value)) {
      formattedValues = Ext.Array.map(value, formatValue);
      return "[" + (formattedValues.join(', ')) + "]";
    }
    if (Ext.isObject(value)) {
      return 'Object';
    }
    if (Ext.isString(value)) {
      return "\"" + value + "\"";
    }
    return '' + value;
  };
  chai.use(function(chai, utils) {
    var assert;

    assert = chai.assert;
    Assertion.addMethod('memberOf', function(array) {
      var value;

      value = utils.flag(this, 'object');
      this.assert(Ext.Array.contains(array, value), 'expected #{this} to be a member of ' + utils.inspect(array), 'expected #{this} to not be a member of ' + +utils.inspect(array));
    });
    Assertion.addMethod('membersOf', function(array) {
      var values;

      values = utils.flag(this, 'object');
      expect(values).to.be.an.Array;
      this.assert(Ext.Array.filter(values, function(value) {
        return !Ext.Array.contains(array, value);
      }).length === 0, 'expected #{this} to be members of ' + utils.inspect(array), 'expected #{this} to not be members of ' + +utils.inspect(array));
    });
    Assertion.addProperty('unique', function() {
      var values;

      values = utils.flag(this, 'object');
      expect(values).to.be.an.instanceOf(Array);
      this.assert(Ext.Array.unique(values).length === values.length, 'expected #{this} to be comprised of unique values', 'expected #{this} not to be comprised of unique values');
    });
    assert.eventuallyThrows = function(error, done, timeout) {
      var originalHandler, restored;

      if (timeout == null) {
        timeout = 50;
      }
      originalHandler = window.onerror;
      restored = false;
      window.onerror = function(message) {
        window.onerror = originalHandler;
        restored = true;
        expect(message).to.contain(error.message);
        done();
      };
      setTimeout(function() {
        if (!restored) {
          window.onerror = originalHandler;
          return done(new Error('expected ' + error + ' to be thrown within ' + timeout + 'ms'));
        }
      }, timeout);
    };
  });
  describe('Custom Assertions', function() {
    specify('memberOf', function() {
      expect(1).to.be.memberOf([1, 2, 3]);
      expect(0).not.to.be.memberOf([1, 2, 3]);
    });
    specify('membersOf', function() {
      expect([1]).to.be.membersOf([1, 2, 3]);
      expect([1, 2]).to.be.membersOf([1, 2, 3]);
      expect([0]).not.to.be.membersOf([1, 2, 3]);
      expect([0, 5]).not.to.be.membersOf([1, 2, 3]);
    });
    specify('unique', function() {
      expect([1, 2, 3]).to.be.unique;
      expect([1, 2, 1]).not.to.be.unique;
    });
    specify('eventuallyThrow', function(done) {
      this.slow(250);
      setTimeout(function() {
        throw new Error('error message');
      }, 0);
      assert.eventuallyThrows(new Error('error message'), done, 100);
    });
  });
  describe('when()', function() {
    var values;

    values = [void 0, null, false, 0, 1, 'expected value', [1, 2, 3], {}, new Error('error message')];
    describe('returns a Promise that will resolve with the specified value', function() {
      var value, _fn, _i, _len;

      _fn = function(value) {
        return specify(formatValue(value), function() {
          var promise;

          promise = Deft.Promise.when(value);
          promise.should.be.an["instanceof"](Deft.Promise);
          return promise.should.eventually.equal(value);
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
    describe('returns a Promise that will resolve with the resolved value for the specified Promise when it resolves', function() {
      var value, _fn, _i, _len;

      _fn = function(value) {
        return specify(formatValue(value), function() {
          var deferred, promise;

          deferred = Ext.create('Deft.Deferred');
          deferred.resolve(value);
          promise = Deft.Promise.when(deferred.promise);
          promise.should.not.be.equal(deferred.promise);
          promise.should.be.an["instanceof"](Deft.Promise);
          return promise.should.eventually.equal(value);
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
    describe('returns a Promise that will reject with the error associated with the specified Promise when it rejects', function() {
      specify('Error: error message', function() {
        var deferred, promise;

        deferred = Ext.create('Deft.Deferred');
        deferred.reject(new Error('error message'));
        promise = Deft.Promise.when(deferred.promise);
        promise.should.not.be.equal(deferred.promise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will adapt the specified untrusted (aka third-party) then-able', function() {
      var MockThirdPartyPromise;

      MockThirdPartyPromise = (function() {
        function MockThirdPartyPromise() {}

        MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
          this.successCallback = successCallback;
          this.failureCallback = failureCallback;
          switch (this.state) {
            case 'resolved':
              this.successCallback(this.value);
              break;
            case 'rejected':
              this.failureCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.resolve = function(value) {
          this.value = value;
          this.state = 'resolved';
          if (this.successCallback != null) {
            this.successCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.reject = function(value) {
          this.value = value;
          this.state = 'rejected';
          if (this.failureCallback != null) {
            this.failureCallback(this.value);
          }
        };

        return MockThirdPartyPromise;

      })();
      specify('resolves when resolved', function() {
        var mockThirdPartyPromise, promise;

        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('rejects when rejected', function() {
        var mockThirdPartyPromise, promise;

        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
  });
  describe('isPromise()', function() {
    describe('returns true for a Deft.Promise or then()-able', function() {
      specify('Deft.Promise', function() {
        var promise;

        promise = Ext.create('Deft.Deferred').promise;
        expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
      specify('returns true for any then()-able', function() {
        var promise;

        promise = {
          then: function() {}
        };
        expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
    });
    return describe('returns false for non-promises', function() {
      var value, values, _fn, _i, _len;

      values = [void 0, null, false, 0, 1, 'value', [1, 2, 3], {}, new Error('error message')];
      _fn = function(value) {
        return specify(formatValue(value), function() {
          expect(Deft.Promise.isPromise(value)).to.be["false"];
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
  });
  describe('all()', function() {
    describe('returns a new Promise that will resolve with the resolved values for the specified Array of Promises(s) or values.', function() {
      specify('Empty Array', function() {
        var promise;

        promise = Deft.Promise.all([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.all(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.all([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.all([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.all([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will resolve with the resolved values for the specified resolved Promise of an Array of Promises(s) or values.', function() {
      specify('Promise of an empty Array', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.all([Deft.Deferred.reject(new Error('error message'))]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.all([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Promise.all(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.all();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.all(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.all(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('any()', function() {
    describe('returns a new Promise that will resolve once any one of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.any(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.any([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.any([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([2, 4, 5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.any([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Array of rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;

        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2]);
      });
    });
    describe('returns a new Promise that will resolve once any one of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([2, 4, 5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.to.be.a.memberOf([1, 2, 3]);
      });
      specify('Promise of an Array of rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2]);
      });
    });
    describe('returns a new Promise that will reject if none of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array', function() {
        var promise;

        promise = Deft.Promise.any([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.any([Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array of rejected Promises', function() {
        var promise;

        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject if none of the specified resolved Promise of an Array of Promises(s) or values resolves.', function() {
      specify('Promise of an empty Array', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Promise of an Array of rejected Promises', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Promise.any(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.any();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.any(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.any(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('some()', function() {
    describe('returns a new Promise that will resolve once the specified number of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.some(['expected value'], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.some([1, 2, 3], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.some([,2,,4,5], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([2, 4, 5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.resolve('expected value')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Array of rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.some([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of rejected Promises and multiple resolved Promises', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
      specify('Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;

        promise = Deft.Promise.some([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
    });
    describe('returns a new Promise that will resolve once the specified number of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when(['expected value']), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([1, 2, 3]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([,2,,4,5]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([2, 4, 5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.resolve('expected value')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Promise of an Array of rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of rejected Promises and multiple resolved Promises', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.reject('error message'), Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
      specify('Promise of an Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Promise.when([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
    });
    describe('returns a new Promise that will reject if too few of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array with one resolved value requested', function() {
        var promise;

        promise = Deft.Promise.some([], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Empty Array with multiple resolved values requested', function() {
        var promise;

        promise = Deft.Promise.some([], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with one resolved value requested', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with multiple resolved values requested', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.reject('error message')], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with one resolved value requested', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with multiple resolved values requested', function() {
        var promise;

        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject if too few of the specified resolved Promise of an Array of Promises(s) or values resolves.', function() {
      specify('Promise of an empty Array with one resolved value requested', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.resolve([]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an empty Array with multiple resolved values requested', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.resolve([]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array with one rejected Promise with one resolved value requested', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array with one rejected Promise with multiple resolved values requested', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array of rejected Promises with one resolved value requested', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array of rejected Promises with multiple resolved values requested', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Promise.some(Deft.Deferred.reject(new Error('error message')), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.some();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.some(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.some(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single Array parameter', function() {
        expect(function() {
          return Deft.Promise.some([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a positive integer.');
      });
      specify('a single Array parameter and a non-numeric value', function() {
        expect(function() {
          return Deft.Promise.some([1, 2, 3], 'value');
        }).to["throw"](Error, 'Invalid parameter: expected a positive integer.');
      });
    });
  });
  describe('delay()', function() {
    var now;

    now = function() {
      return new Date().getTime();
    };
    describe('returns a new Promise that will resolve after the specified delay', function() {
      specify('0 ms delay', function() {
        var promise;

        promise = Deft.Promise.delay(0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(void 0);
      });
      specify('value with 100 ms delay', function() {
        var promise, start;

        this.slow(250);
        promise = Deft.Promise.delay(100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 50);
          return value;
        });
        return promise.should.eventually.equal(void 0);
      });
    });
    describe('returns a new Promise that will resolve with the specified Promise or value after the specified delay', function() {
      specify('value with 0 ms delay', function() {
        var promise;

        promise = Deft.Promise.delay('expected value', 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('resolved Promise with 0 delay', function() {
        var promise;

        promise = Deft.Promise.delay(Deft.Deferred.resolve('expected value'), 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('value with 100 ms delay', function() {
        var promise, start;

        this.slow(250);
        promise = Deft.Promise.delay('expected value', 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 50);
          return value;
        });
        return promise.should.eventually.equal('expected value');
      });
      specify('resolved Promise with 100 ms delay', function() {
        var promise, start;

        this.slow(250);
        promise = Deft.Promise.delay(Deft.Deferred.resolve('expected value'), 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 50);
          return value;
        });
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the specified rejected Promise after the specified delay', function() {
      specify('rejected Promise with 100 ms delay', function() {
        var promise, start;

        this.slow(250);
        promise = Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          return value;
        }, function(error) {
          expect(now() - start).to.be.closeTo(100, 50);
          throw error;
        });
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  describe('timeout()', function() {
    describe('returns a new Promise that will resolve with the specified Promise or value if it resolves before the specified timeout', function() {
      specify('value with 100 ms timeout', function() {
        var promise;

        this.slow(250);
        promise = Deft.Promise.timeout('expected value', 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise that resolves in 50 ms with a 100 ms timeout', function() {
        var promise;

        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay('expected value', 50), 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the specified rejected Promise if it rejects before the specified timeout', function() {
      specify('Promise that rejects in 50 ms with a 100 ms timeout', function() {
        var promise;

        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 50), 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject after the specified timeout if the specified Promise or value has not yet resolved or rejected', function() {
      specify('Promise that resolves in 100 ms with a 50 ms timeout', function() {
        var promise;

        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay('expected value', 100), 50);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Promise timed out.');
      });
      specify('Promise that rejects in 50 ms with a 100 ms timeout', function() {
        var promise;

        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 100), 50);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Promise timed out.');
      });
    });
  });
  describe('memoize()', function() {
    var fibonacci;

    fibonacci = function(n) {
      if (n < 2) {
        return n;
      } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
    };
    describe('returns a new function that wraps the specified function, caching results for previously processed inputs, and returns a Promise that will resolve with the result value', function() {
      specify('value', function() {
        var memoFunction, promise, targetFunction;

        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = Deft.Promise.all([memoFunction(12), memoFunction(12)]).then(function(value) {
          expect(targetFunction).to.be.calledOnce;
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.deep.equal([fibonacci(12), fibonacci(12)]);
      });
      specify('resolved Promise', function() {
        var memoFunction, promise, targetFunction;

        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = Deft.Promise.all([memoFunction(Deft.Deferred.resolve(12)), memoFunction(Deft.Deferred.resolve(12))]).then(function(value) {
          expect(targetFunction).to.be.calledOnce;
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.deep.equal([fibonacci(12), fibonacci(12)]);
      });
    });
    describe('executes the wrapped function in the optionally specified scope', function() {
      specify('optional scope omitted', function() {
        var memoFunction, promise, targetFunction;

        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = memoFunction(12).then(function(value) {
          expect(targetFunction).to.be.calledOnce.and.calledOn(void 0);
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.equal(fibonacci(12));
      });
      specify('scope specified', function() {
        var memoFunction, promise, targetFunction, targetScope;

        targetScope = {};
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction, targetScope);
        promise = memoFunction(12).then(function(value) {
          expect(targetFunction).to.be.calledOnce.and.calledOn(targetScope);
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.equal(fibonacci(12));
      });
    });
    describe('returns a new function that wraps the specified function and returns a Promise that will reject with the associated error when the wrapper function is called with a rejected Promise', function() {
      specify('rejected Promise', function() {
        var memoFunction, promise, targetFunction;

        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = memoFunction(Deft.Deferred.reject(new Error('error message')));
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  describe('map()', function() {
    var doubleFunction, doublePromiseFunction, rejectFunction;

    doubleFunction = function(value, index, array) {
      expect(arguments).to.have.lengthOf(3);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return value * 2;
    };
    doublePromiseFunction = function(value, index, array) {
      expect(arguments).to.have.lengthOf(3);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.resolve(value * 2);
    };
    rejectFunction = function(value, index, array) {
      expect(arguments).to.have.lengthOf(3);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.reject(new Error('error message'));
    };
    describe('returns a new Promise that will resolve with an Array of the mapped values for the specified Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;

        promise = Deft.Promise.map([], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.map([1], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.map([1, 2, 3], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.map([,2,,4,5], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the mapped values for the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Promise of an empty Array', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;

        promise = Deft.Promise.map([], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.map([1], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.map([1, 2, 3], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.map([,2,,4,5], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Promise of an empty Array', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.reject(new Error('error message'))], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map([1, Deft.Deferred.reject(new Error('error message')), 3], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), 3]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.map([1], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.map([1, 2, 3], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.map([,2,,4,5], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Promise.map(Deft.Deferred.reject(new Error('error message')), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than an Array or Promise of an Array and a function are specified', function() {
      specify('no parameters', function() {
        return expect(function() {
          return Deft.Promise.map();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        return expect(function() {
          return Deft.Promise.map(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        return expect(function() {
          return Deft.Promise.map(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('an Array and no function', function() {
        return expect(function() {
          return Deft.Promise.map([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('a Promise of an Array and no function', function() {
        return expect(function() {
          return Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('an Array and a non-function parameter', function() {
        return expect(function() {
          return Deft.Promise.map([1, 2, 3], 'not a function');
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      return specify('a Promise of a non-function parameter', function() {
        return expect(function() {
          return Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3], 'not a function'));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
    });
  });
  describe('reduce()', function() {
    var rejectFunction, sumFunction, sumPromiseFunction;

    sumFunction = function(previousValue, currentValue, index, array) {
      expect(arguments).to.have.lengthOf(4);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return previousValue + currentValue;
    };
    sumPromiseFunction = function(previousValue, currentValue, index, array) {
      expect(arguments).to.have.lengthOf(4);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.resolve(previousValue + currentValue);
    };
    rejectFunction = function(previousValue, currentValue, index, array) {
      expect(arguments).to.have.lengthOf(4);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.reject(new Error('error message'));
    };
    describe('returns a Promise that will resolve with the value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Empty Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([], sumFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Empty Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([], sumFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one value and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one value and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Sparse Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Sparse Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one resolved Promise and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Array of resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Promise of an empty Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an empty Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one value and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one value and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of a sparse Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of a sparse Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one resolved Promise and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Promise of an Array of resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the resolved Promise value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Empty Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([], sumPromiseFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Empty Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([], sumPromiseFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one value and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one value and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3, 4], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3, 4], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3, 4], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Sparse Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Sparse Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one resolved Promise and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Array of resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the resolved Promise value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Promise of an empty Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumPromiseFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an empty Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumPromiseFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one value and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one value and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of a sparse Array and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of a sparse Array and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one resolved Promise and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Promise of an Array of resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and resolved Promises and an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.reject(new Error('error message'))], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.reject(new Error('error message')), 3], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), 3]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.reject(new Error('error message')), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified Array of Promise(s) or value(s)', function() {
      specify('Array with one value', function() {
        var promise;

        promise = Deft.Promise.reduce([1], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;

        promise = Deft.Promise.reduce([,2,,4,5], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Promise of an Array with one value', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of a sparse Array', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an initial value', function() {
      specify('Error: error message', function() {
        var promise;

        promise = Deft.Promise.reduce([1, 2, 3], sumFunction, Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject if reduce is attempted on an empty Array with no initial value specified', function() {
      specify('Empty Array', function() {
        var promise;

        promise = Deft.Promise.reduce([], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](TypeError);
      });
      specify('Promise of an empty Array', function() {
        var promise;

        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](TypeError);
      });
    });
    describe('throws an Error if anything other than an Array or Promise of an Array and a function are specified as the first two parameters', function() {
      specify('no parameters', function() {
        return expect(function() {
          return Deft.Promise.reduce();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        return expect(function() {
          return Deft.Promise.reduce(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        return expect(function() {
          return Deft.Promise.reduce(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('an Array and no function', function() {
        return expect(function() {
          return Deft.Promise.reduce([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('a Promise of an Array and no function', function() {
        return expect(function() {
          return Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3]));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('an Array and a non-function parameter', function() {
        return expect(function() {
          return Deft.Promise.reduce([1, 2, 3], 'not a function');
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      return specify('a Promise of a non-function parameter', function() {
        return expect(function() {
          return Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3], 'not a function'));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
    });
  });
  describe('otherwise()', function() {
    describe('attaches a callback that will be called if this Promise is rejected', function() {
      specify('called if rejected', function(done) {
        var error, onRejected, promise;

        onRejected = sinon.spy();
        error = new Error('error message');
        promise = Deft.Deferred.reject(error);
        promise.otherwise(onRejected);
        promise.then(null, function() {
          try {
            expect(onRejected).to.be.calledOnce.and.calledWith(error);
            return done();
          } catch (_error) {
            error = _error;
            return done(error);
          }
        });
      });
      specify('called in specified scope if rejected', function(done) {
        var error, onRejected, promise, targetScope;

        targetScope = {};
        onRejected = sinon.spy();
        error = new Error('error message');
        promise = Deft.Deferred.reject(error);
        promise.otherwise(onRejected, targetScope);
        promise.then(null, function() {
          try {
            expect(onRejected).to.be.calledOnce.and.calledWith(error).and.calledOn(targetScope);
            return done();
          } catch (_error) {
            error = _error;
            return done(error);
          }
        });
      });
      specify('not called if resolved', function(done) {
        var onRejected, promise;

        onRejected = sinon.spy();
        promise = Deft.Deferred.resolve('value');
        promise.otherwise(onRejected);
        promise.then(function() {
          var error;

          try {
            expect(onRejected).not.to.be.called;
            return done();
          } catch (_error) {
            error = _error;
            return done(error);
          }
        });
      });
    });
    describe('returns a Promise of the transformed future value', function() {
      specify('resolves with the returned value if callback returns a value', function() {
        var onRejected, promise;

        onRejected = function() {
          return 'returned value';
        };
        promise = Deft.Deferred.reject(new Error('error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('returned value');
      });
      specify('resolves with the resolved value if callback returns a Promise that resolves with value', function() {
        var onRejected, promise;

        onRejected = function() {
          return Deft.Deferred.resolve('resolved value');
        };
        promise = Deft.Deferred.reject(new Error('error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('rejects with the thrown Error if callback throws an Error', function() {
        var onRejected, promise;

        onRejected = function() {
          throw new Error('thrown error message');
        };
        promise = Deft.Deferred.reject(new Error('error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'thrown error message');
      });
      specify('rejects with the rejection reason if callback returns a Promise that rejects with a reason', function() {
        var onRejected, promise;

        onRejected = function() {
          return Deft.Deferred.reject(new Error('rejection reason'));
        };
        promise = Deft.Deferred.reject(new Error('original error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
    });
  });
  describe('always()', function() {
    describe('attaches a callback to this Promise that will be called when it resolves or rejects', function() {
      specify('called with no parameters when resolved', function(done) {
        var onComplete, promise;

        onComplete = sinon.spy();
        promise = Deft.Deferred.resolve('value');
        promise.always(onComplete);
        promise.then(function() {
          var error;

          try {
            expect(onComplete).to.be.called;
            return done();
          } catch (_error) {
            error = _error;
            return done(error);
          }
        });
      });
      specify('called with no parameters when rejected', function(done) {
        var onComplete, promise;

        onComplete = sinon.spy();
        promise = Deft.Deferred.reject(new Error('error message'));
        promise.always(onComplete);
        promise.then(null, function() {
          var error;

          try {
            expect(onComplete).to.be.called;
            return done();
          } catch (_error) {
            error = _error;
            return done(error);
          }
        });
      });
    });
    describe('return a new "pass-through" Promise that resolves with the original value or rejects with the original reason', function() {
      specify('if the originating Promise resolves, ignores value returned by callback', function() {
        var onComplete, promise;

        onComplete = function() {
          return 'callback return value';
        };
        promise = Deft.Deferred.resolve('resolved value').always(onComplete);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('if the originating Promise resolves, ignores and later rethrows Error thrown by callback', function() {
        var onComplete, promise;

        onComplete = function() {
          throw new Error('callback error message');
        };
        promise = Deft.Deferred.resolve('resolved value').always(onComplete);
        assert.eventuallyThrows(new Error('callback error message'), function(error) {
          if (error) {
            throw error;
          }
        }, 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('if the originating Promise rejects, ignores value returned by callback', function() {
        var onComplete, promise;

        onComplete = function() {
          return 'callback return value';
        };
        promise = Deft.Deferred.reject(new Error('rejection reason')).always(onComplete);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
      specify('if the originating Promise rejects, ignores and later rethrows Error thrown by callback', function() {
        var onComplete, promise;

        onComplete = function() {
          throw new Error('callback error message');
        };
        promise = Deft.Deferred.reject(new Error('rejection reason')).always(onComplete);
        assert.eventuallyThrows(new Error('callback error message'), function(error) {
          if (error) {
            throw error;
          }
        }, 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
    });
  });
  describe('then() - with a progress handler', function() {
    describe('should register the specified progress handler and propagate future transformed progress updates that originate from this Promise', function() {
      specify('registers the specified progress handler to be notified with future progress updates', function(done) {
        var deferred, progressHandler, promise;

        deferred = Ext.create('Deft.Deferred');
        promise = deferred.promise;
        progressHandler = sinon.spy();
        promise.then(null, null, progressHandler);
        Deft.Function.nextTick(function() {
          deferred.update('progress');
          expect(progressHandler).to.be.calledOnce.and.calledWith('progress');
          done();
        });
      });
      specify('propagates future progress updates to subsequent Promises in the chain if a progress handler is omitted', function(done) {
        var deferred, progressHandler, promise;

        deferred = Ext.create('Deft.Deferred');
        promise = deferred.promise;
        progressHandler = sinon.spy();
        promise.then().then(null, null, progressHandler);
        Deft.Function.nextTick(function() {
          deferred.update('progress');
          expect(progressHandler).to.be.calledOnce.and.calledWith('progress');
          done();
        });
      });
      specify('propagates future transformed progress updates to subsequent Promises in the chain if a progress handler transforms the progress update', function(done) {
        var deferred, progressHandler, promise, transformedProgressHandler, transformedTransformedProgressHandler;

        deferred = Ext.create('Deft.Deferred');
        promise = deferred.promise;
        progressHandler = sinon.stub().returns('transformed progress');
        transformedProgressHandler = sinon.stub().returns('transformed transformed progress');
        transformedTransformedProgressHandler = sinon.spy();
        promise.then(null, null, progressHandler).then(null, null, transformedProgressHandler).then(null, null, transformedTransformedProgressHandler);
        Deft.Function.nextTick(function() {
          deferred.update('progress');
          expect(progressHandler).to.be.calledOnce.and.calledWith('progress');
          expect(transformedProgressHandler).to.be.calledOnce.and.calledWith('transformed progress');
          expect(transformedTransformedProgressHandler).to.be.calledOnce.and.calledWith('transformed transformed progress');
          done();
        });
      });
    });
  });
  describe('done()', function() {
    describe('terminates a Promise chain, ensuring that unhandled rejections will be thrown as Errors', function() {
      specify('rethrows the rejection as an error if the originating Promise rejects', function(done) {
        var promise;

        this.slow(250);
        promise = Deft.Deferred.reject(new Error('rejection reason')).done();
        assert.eventuallyThrows(new Error('rejection reason'), done, 100);
      });
      specify('rethrows the rejection as an error if an ancestor Promise rejects and that rejection is unhandled', function(done) {
        var promise;

        this.slow(250);
        promise = Deft.Deferred.reject(new Error('rejection reason')).then(function(value) {
          return value;
        }).done();
        assert.eventuallyThrows(new Error('rejection reason'), done, 100);
      });
    });
  });
  describe('cancel()', function() {
    describe('cancels a Promise if it is still pending, triggering a rejection with a CancellationError that will propagate to any Promises originating from that Promise', function() {
      specify('rejects a pending Promise with a CancellationError', function() {
        var promise;

        promise = Ext.create('Deft.Deferred').promise;
        promise.cancel();
        return promise.should.be.rejected["with"](CancellationError);
      });
      specify('rejects a pending Promise with a CancellationError with a reason', function() {
        var promise;

        promise = Ext.create('Deft.Deferred').promise;
        promise.cancel('cancellation reason');
        return promise.should.be.rejected["with"](CancellationError, 'cancellation reason');
      });
      specify('ignores attempts to cancel a fulfilled Promise', function() {
        var promise;

        promise = Deft.Deferred.resolve('resolved value');
        promise.cancel();
        return promise.should.eventually.equal('resolved value');
      });
      specify('ignores attempts to cancel a rejected Promise', function() {
        var promise;

        promise = Deft.Deferred.reject(new Error('rejection reason'));
        promise.cancel();
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
      specify('propagates rejection with that CancellationError to Promises that originate from the cancelled Promise', function() {
        var promise;

        promise = Ext.create('Deft.Deferred').promise;
        promise.cancel('cancellation reason');
        return promise.then().should.be.rejected["with"](CancellationError, 'cancellation reason');
      });
    });
  });
  return describe('log()', function() {
    describe('logs the resolution or rejection of this Promise using Deft.Logger.log()', function() {
      beforeEach(function() {
        return sinon.spy(Deft.Logger, 'log');
      });
      afterEach(function() {
        return Deft.Logger.log.restore();
      });
      specify('logs a fulfilled promise', function(done) {
        var promise, value;

        value = 'resolved value';
        promise = Deft.Deferred.resolve(value).log();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;

          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Promise resolved with value: " + value);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
      specify('logs a fulfilled promise, with the optional name specified', function(done) {
        var promise, value;

        value = 'resolved value';
        promise = Deft.Deferred.resolve(value).log('Test Promise');
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;

          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Test Promise resolved with value: " + value);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
      specify('logs a rejected promise', function(done) {
        var promise, reason;

        reason = new Error('rejection reason');
        promise = Deft.Deferred.reject(reason).log();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;

          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Promise rejected with reason: " + reason);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
      specify('logs a rejected promise, with the optional name specified', function(done) {
        var promise, reason;

        reason = new Error('rejection reason');
        promise = Deft.Deferred.reject(reason).log('Test Promise');
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;

          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Test Promise rejected with reason: " + reason);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
    });
    describe('return a new "pass-through" Promise that resolves with the original value or rejects with the original reason', function() {
      specify('resolves if the originating Promise resolves', function() {
        var promise;

        promise = Deft.Deferred.resolve('resolved value').log();
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('rejects if the originating Promise rejects', function() {
        var promise;

        promise = Deft.Deferred.reject(new Error('rejection reason')).log();
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
    });
  });
});
