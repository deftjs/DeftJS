// Generated by CoffeeScript 1.6.3
/*
Copyright (c) 2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

describe('Deft.promise.Promise', function() {
  var formatValue;
  formatValue = function(value) {
    var formattedValues;
    if (value instanceof Deft.promise.Promise) {
      return 'Deft.Promise';
    }
    if (value instanceof Deft.promise.Deferred) {
      return 'Deft.Deferred';
    }
    if (value instanceof Ext.ClassManager.get('Ext.Base')) {
      return Ext.ClassManager.getName(value);
    }
    if (Ext.isArray(value)) {
      formattedValues = Ext.Array.map(value, formatValue);
      return "[" + (formattedValues.join(', ')) + "]";
    }
    if (Ext.isObject(value)) {
      return 'Object';
    }
    if (Ext.isString(value)) {
      return "\"" + value + "\"";
    }
    return '' + value;
  };
  chai.use(function(chai, utils) {
    var assert;
    assert = chai.assert;
    Assertion.addMethod('memberOf', function(array) {
      var value;
      value = utils.flag(this, 'object');
      this.assert(Ext.Array.contains(array, value), 'expected #{this} to be a member of ' + utils.inspect(array), 'expected #{this} to not be a member of ' + +utils.inspect(array));
    });
    Assertion.addMethod('membersOf', function(array) {
      var values;
      values = utils.flag(this, 'object');
      expect(values).to.be.an.Array;
      this.assert(Ext.Array.filter(values, function(value) {
        return !Ext.Array.contains(array, value);
      }).length === 0, 'expected #{this} to be members of ' + utils.inspect(array), 'expected #{this} to not be members of ' + +utils.inspect(array));
    });
    Assertion.addProperty('unique', function() {
      var values;
      values = utils.flag(this, 'object');
      expect(values).to.be.an.instanceOf(Array);
      this.assert(Ext.Array.unique(values).length === values.length, 'expected #{this} to be comprised of unique values', 'expected #{this} not to be comprised of unique values');
    });
    assert.eventuallyThrows = function(error, done, timeout) {
      var originalHandler, restored;
      if (timeout == null) {
        timeout = 50;
      }
      originalHandler = window.onerror;
      restored = false;
      window.onerror = function(message) {
        window.onerror = originalHandler;
        restored = true;
        expect(message).to.contain(error.message);
        done();
      };
      setTimeout(function() {
        if (!restored) {
          window.onerror = originalHandler;
          return done(new Error('expected ' + error + ' to be thrown within ' + timeout + 'ms'));
        }
      }, timeout);
    };
  });
  describe('Custom Assertions', function() {
    specify('memberOf', function() {
      expect(1).to.be.memberOf([1, 2, 3]);
      expect(0).not.to.be.memberOf([1, 2, 3]);
    });
    specify('membersOf', function() {
      expect([1]).to.be.membersOf([1, 2, 3]);
      expect([1, 2]).to.be.membersOf([1, 2, 3]);
      expect([0]).not.to.be.membersOf([1, 2, 3]);
      expect([0, 5]).not.to.be.membersOf([1, 2, 3]);
    });
    specify('unique', function() {
      expect([1, 2, 3]).to.be.unique;
      expect([1, 2, 1]).not.to.be.unique;
    });
    specify('eventuallyThrow', function(done) {
      this.slow(250);
      setTimeout(function() {
        throw new Error('error message');
      }, 0);
      assert.eventuallyThrows(new Error('error message'), done, 100);
    });
  });
  describe('when()', function() {
    var values;
    values = [void 0, null, false, 0, 1, 'expected value', [1, 2, 3], {}, new Error('error message')];
    describe('returns a Promise that will resolve with the specified value', function() {
      var value, _fn, _i, _len;
      _fn = function(value) {
        return specify(formatValue(value), function() {
          var promise;
          promise = Deft.Promise.when(value);
          promise.should.be.an["instanceof"](Deft.Promise);
          return promise.should.eventually.equal(value);
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
    describe('returns a Promise that will resolve with the resolved value for the specified Promise when it resolves', function() {
      var value, _fn, _i, _len;
      _fn = function(value) {
        return specify(formatValue(value), function() {
          var deferred, promise;
          deferred = Ext.create('Deft.Deferred');
          deferred.resolve(value);
          promise = Deft.Promise.when(deferred.promise);
          promise.should.not.be.equal(deferred.promise);
          promise.should.be.an["instanceof"](Deft.Promise);
          return promise.should.eventually.equal(value);
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
    describe('returns a Promise that will reject with the error associated with the specified Promise when it rejects', function() {
      specify('Error: error message', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.Deferred');
        deferred.reject(new Error('error message'));
        promise = Deft.Promise.when(deferred.promise);
        promise.should.not.be.equal(deferred.promise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will adapt the specified untrusted (aka third-party) then-able', function() {
      var MockThirdPartyPromise;
      MockThirdPartyPromise = (function() {
        function MockThirdPartyPromise() {}

        MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
          this.successCallback = successCallback;
          this.failureCallback = failureCallback;
          switch (this.state) {
            case 'resolved':
              this.successCallback(this.value);
              break;
            case 'rejected':
              this.failureCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.resolve = function(value) {
          this.value = value;
          this.state = 'resolved';
          if (this.successCallback != null) {
            this.successCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.reject = function(value) {
          this.value = value;
          this.state = 'rejected';
          if (this.failureCallback != null) {
            this.failureCallback(this.value);
          }
        };

        return MockThirdPartyPromise;

      })();
      specify('resolves when resolved', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('rejects when rejected', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
  });
  describe('isPromise()', function() {
    describe('returns true for a Deft.Promise or then()-able', function() {
      specify('Deft.Promise', function() {
        var promise;
        promise = Ext.create('Deft.Deferred').promise;
        expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
      specify('returns true for any then()-able', function() {
        var promise;
        promise = {
          then: function() {}
        };
        expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
    });
    describe('returns false for non-promises', function() {
      var value, values, _fn, _i, _len;
      values = [void 0, null, false, 0, 1, 'value', [1, 2, 3], {}, new Error('error message')];
      _fn = function(value) {
        return specify(formatValue(value), function() {
          expect(Deft.Promise.isPromise(value)).to.be["false"];
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
  });
  describe('all()', function() {
    describe('returns a new Promise that will resolve with the resolved values for the specified Array of Promises(s) or values.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.all([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.all(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.all([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.all([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will resolve with the resolved values for the specified resolved Promise of an Array of Promises(s) or values.', function() {
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.reject(new Error('error message'))]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.all();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.all(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.all(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('any()', function() {
    describe('returns a new Promise that will resolve once any one of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.any(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.any([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.any([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([2, 4, 5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2]);
      });
    });
    describe('returns a new Promise that will resolve once any one of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([2, 4, 5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.to.be.a.memberOf([1, 2, 3]);
      });
      specify('Promise of an Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2]);
      });
    });
    describe('returns a new Promise that will reject if none of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.any([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array of rejected Promises', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject if none of the specified resolved Promise of an Array of Promises(s) or values resolves.', function() {
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Promise of an Array of rejected Promises', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.any();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.any(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.any(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('some()', function() {
    describe('returns a new Promise that will resolve once the specified number of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.some(['expected value'], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.some([1, 2, 3], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.some([,2,,4,5], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([2, 4, 5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.resolve('expected value')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
      specify('Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
    });
    describe('returns a new Promise that will resolve once the specified number of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when(['expected value']), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([1, 2, 3]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([,2,,4,5]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([2, 4, 5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.resolve('expected value')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Promise of an Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.reject('error message'), Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
      specify('Promise of an Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
    });
    describe('returns a new Promise that will reject if too few of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some([], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Empty Array with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some([], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message')], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject if too few of the specified resolved Promise of an Array of Promises(s) or values resolves.', function() {
      specify('Promise of an empty Array with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an empty Array with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array with one rejected Promise with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array with one rejected Promise with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array of rejected Promises with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Promise of an Array of rejected Promises with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.reject(new Error('error message')), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.some();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.some(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.some(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single Array parameter', function() {
        expect(function() {
          return Deft.Promise.some([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a positive integer.');
      });
      specify('a single Array parameter and a non-numeric value', function() {
        expect(function() {
          return Deft.Promise.some([1, 2, 3], 'value');
        }).to["throw"](Error, 'Invalid parameter: expected a positive integer.');
      });
    });
  });
  describe('delay()', function() {
    var now;
    now = function() {
      return new Date().getTime();
    };
    describe('returns a new Promise that will resolve after the specified delay', function() {
      specify('0 ms delay', function() {
        var promise;
        promise = Deft.Promise.delay(0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(void 0);
      });
      specify('value with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay(100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 50);
          return value;
        });
        return promise.should.eventually.equal(void 0);
      });
    });
    describe('returns a new Promise that will resolve with the specified Promise or value after the specified delay', function() {
      specify('value with 0 ms delay', function() {
        var promise;
        promise = Deft.Promise.delay('expected value', 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('resolved Promise with 0 delay', function() {
        var promise;
        promise = Deft.Promise.delay(Deft.Deferred.resolve('expected value'), 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('value with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay('expected value', 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 50);
          return value;
        });
        return promise.should.eventually.equal('expected value');
      });
      specify('resolved Promise with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay(Deft.Deferred.resolve('expected value'), 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 50);
          return value;
        });
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the specified rejected Promise after the specified delay', function() {
      specify('rejected Promise with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          return value;
        }, function(error) {
          expect(now() - start).to.be.closeTo(100, 50);
          throw error;
        });
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  describe('timeout()', function() {
    describe('returns a new Promise that will resolve with the specified Promise or value if it resolves before the specified timeout', function() {
      specify('value with 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout('expected value', 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise that resolves in 50 ms with a 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay('expected value', 50), 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the specified rejected Promise if it rejects before the specified timeout', function() {
      specify('Promise that rejects in 50 ms with a 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 50), 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject after the specified timeout if the specified Promise or value has not yet resolved or rejected', function() {
      specify('Promise that resolves in 100 ms with a 50 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay('expected value', 100), 50);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Promise timed out.');
      });
      specify('Promise that rejects in 50 ms with a 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 100), 50);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Promise timed out.');
      });
    });
  });
  describe('memoize()', function() {
    var fibonacci;
    fibonacci = function(n) {
      if (n < 2) {
        return n;
      } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
    };
    describe('returns a new function that wraps the specified function, caching results for previously processed inputs, and returns a Promise that will resolve with the result value', function() {
      specify('value', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = Deft.Promise.all([memoFunction(12), memoFunction(12)]).then(function(value) {
          expect(targetFunction).to.be.calledOnce;
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.deep.equal([fibonacci(12), fibonacci(12)]);
      });
      specify('resolved Promise', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = Deft.Promise.all([memoFunction(Deft.Deferred.resolve(12)), memoFunction(Deft.Deferred.resolve(12))]).then(function(value) {
          expect(targetFunction).to.be.calledOnce;
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.deep.equal([fibonacci(12), fibonacci(12)]);
      });
    });
    describe('executes the wrapped function in the optionally specified scope', function() {
      specify('optional scope omitted', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = memoFunction(12).then(function(value) {
          expect(targetFunction).to.be.calledOnce.and.calledOn(void 0);
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.equal(fibonacci(12));
      });
      specify('scope specified', function() {
        var memoFunction, promise, targetFunction, targetScope;
        targetScope = {};
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction, targetScope);
        promise = memoFunction(12).then(function(value) {
          expect(targetFunction).to.be.calledOnce.and.calledOn(targetScope);
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.equal(fibonacci(12));
      });
    });
    describe('returns a new function that wraps the specified function and returns a Promise that will reject with the associated error when the wrapper function is called with a rejected Promise', function() {
      specify('rejected Promise', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = memoFunction(Deft.Deferred.reject(new Error('error message')));
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  describe('map()', function() {
    var doubleFunction, doublePromiseFunction, rejectFunction;
    doubleFunction = function(value, index, array) {
      expect(arguments).to.have.lengthOf(3);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return value * 2;
    };
    doublePromiseFunction = function(value, index, array) {
      expect(arguments).to.have.lengthOf(3);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.resolve(value * 2);
    };
    rejectFunction = function(value, index, array) {
      expect(arguments).to.have.lengthOf(3);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.reject(new Error('error message'));
    };
    describe('returns a new Promise that will resolve with an Array of the mapped values for the specified Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.map([], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map([1], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, 3], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map([,2,,4,5], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the mapped values for the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.map([], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map([1], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, 3], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map([,2,,4,5], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.reject(new Error('error message'))], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.reject(new Error('error message')), 3], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), 3]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map([1], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, 3], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map([,2,,4,5], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.reject(new Error('error message')), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than an Array or Promise of an Array and a function are specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.map();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.map(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.map(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('an Array and no function', function() {
        expect(function() {
          return Deft.Promise.map([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('a Promise of an Array and no function', function() {
        expect(function() {
          return Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('an Array and a non-function parameter', function() {
        expect(function() {
          return Deft.Promise.map([1, 2, 3], 'not a function');
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('a Promise of a non-function parameter', function() {
        expect(function() {
          return Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3], 'not a function'));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
    });
  });
  describe('reduce()', function() {
    var rejectFunction, sumFunction, sumPromiseFunction;
    sumFunction = function(previousValue, currentValue, index, array) {
      expect(arguments).to.have.lengthOf(4);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return previousValue + currentValue;
    };
    sumPromiseFunction = function(previousValue, currentValue, index, array) {
      expect(arguments).to.have.lengthOf(4);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.resolve(previousValue + currentValue);
    };
    rejectFunction = function(previousValue, currentValue, index, array) {
      expect(arguments).to.have.lengthOf(4);
      expect(array).to.be["instanceof"](Array);
      expect(index).to.be.at.least(0).and.lessThan(array.length);
      return Deft.Deferred.reject(new Error('error message'));
    };
    describe('returns a Promise that will resolve with the value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Empty Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([], sumFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Empty Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([], sumFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one value and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one value and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Sparse Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Sparse Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one resolved Promise and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Array of resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Promise of an empty Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an empty Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one value and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one value and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of a sparse Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of a sparse Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one resolved Promise and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Promise of an Array of resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the resolved Promise value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Empty Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([], sumPromiseFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Empty Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([], sumPromiseFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one value and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one value and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Sparse Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Sparse Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one resolved Promise and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Array of resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the resolved Promise value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Promise of an empty Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumPromiseFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an empty Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumPromiseFunction, Deft.Deferred.resolve(0));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one value and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one value and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of a sparse Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of a sparse Array and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Promise of an Array with one resolved Promise and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array with one resolved Promise and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Promise of an Array of resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumPromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Promise of an Array of values and resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumPromiseFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Promise of an Array of values and resolved Promises and a resolved Promise of an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumPromiseFunction, Deft.Deferred.resolve(10));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.reject(new Error('error message'))], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.reject(new Error('error message')), 3], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), 3]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.reject(new Error('error message')), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified Array of Promise(s) or value(s)', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an initial value', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3], sumFunction, Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject if reduce is attempted on an empty Array with no initial value specified', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.reduce([], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](TypeError);
      });
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](TypeError);
      });
    });
    describe('throws an Error if anything other than an Array or Promise of an Array and a function are specified as the first two parameters', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.reduce();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.reduce(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.reduce(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('an Array and no function', function() {
        expect(function() {
          return Deft.Promise.reduce([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('a Promise of an Array and no function', function() {
        expect(function() {
          return Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3]));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('an Array and a non-function parameter', function() {
        expect(function() {
          return Deft.Promise.reduce([1, 2, 3], 'not a function');
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
      specify('a Promise of a non-function parameter', function() {
        expect(function() {
          return Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3], 'not a function'));
        }).to["throw"](Error, 'Invalid parameter: expected a function.');
      });
    });
  });
  describe('then()', function() {
    describe('with a progress handler', function() {
      describe('attaches a progress handler that will be called on progress updates', function() {
        specify('called with progress update when updated', function(done) {
          var deferred, progressHandler, promise;
          progressHandler = sinon.spy();
          deferred = Ext.create('Deft.Deferred');
          promise = deferred.promise;
          promise.then(null, null, progressHandler);
          Deft.Function.nextTick(function() {
            deferred.update('progress');
            expect(progressHandler).to.be.calledOnce.and.calledWith('progress');
            done();
          });
        });
        specify('called with progress update in specified scope when updated', function(done) {
          var deferred, progressHandler, promise, targetScope;
          targetScope = {};
          progressHandler = sinon.spy();
          deferred = Ext.create('Deft.Deferred');
          promise = deferred.promise;
          promise.then(null, null, progressHandler, targetScope);
          Deft.Function.nextTick(function() {
            deferred.update('progress');
            expect(progressHandler).to.be.calledOnce.and.calledWith('progress').and.calledOn(targetScope);
            done();
          });
        });
      });
      describe('propagates transformed progress updates that originate from this Promise', function() {
        specify('propagates progress updates to subsequent Promises in the chain if a progress handler is omitted', function(done) {
          var deferred, progressHandler, promise;
          progressHandler = sinon.spy();
          deferred = Ext.create('Deft.Deferred');
          promise = deferred.promise;
          promise.then().then(null, null, progressHandler);
          Deft.Function.nextTick(function() {
            deferred.update('progress');
            expect(progressHandler).to.be.calledOnce.and.calledWith('progress');
            done();
          });
        });
        specify('propagates transformed progress updates to subsequent Promises in the chain if a progress handler transforms the progress update', function(done) {
          var deferred, progressHandler, promise, transformedProgressHandler, transformedTransformedProgressHandler;
          progressHandler = sinon.stub().returns('transformed progress');
          transformedProgressHandler = sinon.stub().returns('transformed transformed progress');
          transformedTransformedProgressHandler = sinon.spy();
          deferred = Ext.create('Deft.Deferred');
          promise = deferred.promise;
          promise.then(null, null, progressHandler).then(null, null, transformedProgressHandler).then(null, null, transformedTransformedProgressHandler);
          Deft.Function.nextTick(function() {
            deferred.update('progress');
            expect(progressHandler).to.be.calledOnce.and.calledWith('progress');
            expect(transformedProgressHandler).to.be.calledOnce.and.calledWith('transformed progress');
            expect(transformedTransformedProgressHandler).to.be.calledOnce.and.calledWith('transformed transformed progress');
            done();
          });
        });
      });
    });
    describe('with parameters specified via a configuration object', function() {
      describe('attaches an onResolved callback to this Promise that will be called when it resolves', function() {
        describe('when only a success handler is specified', function() {
          specify('called with resolved value when resolved', function(done) {
            var onResolved, promise;
            onResolved = sinon.spy();
            promise = Deft.Deferred.resolve('resolved value');
            promise.then({
              success: onResolved
            });
            Deft.Function.nextTick(function() {
              expect(onResolved).to.be.calledOnce.and.calledWith('resolved value');
              done();
            });
          });
          specify('called with resolved value in the specified scope when resolved', function(done) {
            var onResolved, promise, targetScope;
            targetScope = {};
            onResolved = sinon.spy();
            promise = Deft.Deferred.resolve('resolved value');
            promise.then({
              success: onResolved,
              scope: targetScope
            });
            Deft.Function.nextTick(function() {
              expect(onResolved).to.be.calledOnce.and.calledWith('resolved value').and.calledOn(targetScope);
              done();
            });
          });
        });
        describe('when success, failure and progress handlers are specified', function() {
          specify('called with resolved value when resolved', function(done) {
            var onProgress, onRejected, onResolved, promise;
            onResolved = sinon.spy();
            onRejected = sinon.spy();
            onProgress = sinon.spy();
            promise = Deft.Deferred.resolve('resolved value');
            promise.then({
              success: onResolved,
              failure: onRejected,
              progress: onProgress
            });
            Deft.Function.nextTick(function() {
              expect(onResolved).to.be.calledOnce.and.calledWith('resolved value');
              expect(onRejected).to.not.be.called;
              expect(onProgress).to.not.be.called;
              done();
            });
          });
          specify('called with resolved value in the specified scope when resolved', function(done) {
            var onProgress, onRejected, onResolved, promise, targetScope;
            targetScope = {};
            onResolved = sinon.spy();
            onRejected = sinon.spy();
            onProgress = sinon.spy();
            promise = Deft.Deferred.resolve('resolved value');
            promise.then({
              success: onResolved,
              failure: onRejected,
              progress: onProgress,
              scope: targetScope
            });
            Deft.Function.nextTick(function() {
              expect(onResolved).to.be.calledOnce.and.calledWith('resolved value').and.calledOn(targetScope);
              expect(onRejected).to.not.be.called;
              expect(onProgress).to.not.be.called;
              done();
            });
          });
        });
      });
      describe('attaches an onRejected callback to this Promise that will be called when it rejects', function() {
        describe('when only a failure handler is specified', function() {
          specify('called with rejection reason when rejected', function(done) {
            var onRejected, promise;
            onRejected = sinon.spy();
            promise = Deft.Deferred.reject('rejection reason');
            promise.then({
              failure: onRejected
            });
            Deft.Function.nextTick(function() {
              expect(onRejected).to.be.calledOnce.and.calledWith('rejection reason');
              done();
            });
          });
          specify('called with rejection reason in specified scope when rejected', function(done) {
            var onRejected, promise, targetScope;
            targetScope = {};
            onRejected = sinon.spy();
            promise = Deft.Deferred.reject('rejection reason');
            promise.then({
              failure: onRejected,
              scope: targetScope
            });
            Deft.Function.nextTick(function() {
              expect(onRejected).to.be.calledOnce.and.calledWith('rejection reason').and.calledOn(targetScope);
              done();
            });
          });
        });
        describe('when success, failure and progress handlers are specified', function() {
          specify('called with rejection reason when rejected', function(done) {
            var onProgress, onRejected, onResolved, promise;
            onResolved = sinon.spy();
            onRejected = sinon.spy();
            onProgress = sinon.spy();
            promise = Deft.Deferred.reject('rejection reason');
            promise.then({
              success: onResolved,
              failure: onRejected,
              progress: onProgress
            });
            Deft.Function.nextTick(function() {
              expect(onResolved).to.not.be.called;
              expect(onRejected).to.be.calledOnce.and.calledWith('rejection reason');
              expect(onProgress).to.not.be.called;
              done();
            });
          });
          specify('called with rejection reason in specified scope when rejected', function(done) {
            var onProgress, onRejected, onResolved, promise, targetScope;
            targetScope = {};
            onResolved = sinon.spy();
            onRejected = sinon.spy();
            onProgress = sinon.spy();
            promise = Deft.Deferred.reject('rejection reason');
            promise.then({
              success: onResolved,
              failure: onRejected,
              progress: onProgress,
              scope: targetScope
            });
            Deft.Function.nextTick(function() {
              expect(onResolved).to.not.be.called;
              expect(onRejected).to.be.calledOnce.and.calledWith('rejection reason').and.calledOn(targetScope);
              expect(onProgress).to.not.be.called;
              done();
            });
          });
        });
      });
      describe('attaches an onProgress callback to this Promise that will be called when it resolves', function() {
        describe('when only a progress handler is specified', function() {
          specify('called with progress update when updated', function(done) {
            var deferred, onProgress, promise;
            onProgress = sinon.spy();
            deferred = Ext.create('Deft.Deferred');
            promise = deferred.promise;
            promise.then({
              progress: onProgress
            });
            Deft.Function.nextTick(function() {
              deferred.update('progress');
              expect(onProgress).to.be.calledOnce.and.calledWith('progress');
              done();
            });
          });
          specify('called with progress update in specified scope when updated', function(done) {
            var deferred, onProgress, promise, targetScope;
            targetScope = {};
            onProgress = sinon.spy();
            deferred = Ext.create('Deft.Deferred');
            promise = deferred.promise;
            promise.then({
              progress: onProgress,
              scope: targetScope
            });
            Deft.Function.nextTick(function() {
              deferred.update('progress');
              expect(onProgress).to.be.calledOnce.and.calledWith('progress').and.calledOn(targetScope);
              done();
            });
          });
        });
        describe('when success, failure and progress handlers are specified', function() {
          specify('called with progress update when updated', function(done) {
            var deferred, onProgress, onRejected, onResolved, promise;
            onResolved = sinon.spy();
            onRejected = sinon.spy();
            onProgress = sinon.spy();
            deferred = Ext.create('Deft.Deferred');
            promise = deferred.promise;
            promise.then({
              success: onResolved,
              failure: onRejected,
              progress: onProgress
            });
            Deft.Function.nextTick(function() {
              deferred.update('progress');
              expect(onResolved).to.not.be.called;
              expect(onRejected).to.not.be.called;
              expect(onProgress).to.be.calledOnce.and.calledWith('progress');
              done();
            });
          });
          specify('called with progress update in specified scope when updated', function(done) {
            var deferred, onProgress, onRejected, onResolved, promise, targetScope;
            targetScope = {};
            onResolved = sinon.spy();
            onRejected = sinon.spy();
            onProgress = sinon.spy();
            deferred = Ext.create('Deft.Deferred');
            promise = deferred.promise;
            promise.then({
              success: onResolved,
              failure: onRejected,
              progress: onProgress,
              scope: targetScope
            });
            Deft.Function.nextTick(function() {
              deferred.update('progress');
              expect(onResolved).to.not.be.called;
              expect(onRejected).to.not.be.called;
              expect(onProgress).to.be.calledOnce.and.calledWith('progress').and.calledOn(targetScope);
              done();
            });
          });
        });
      });
    });
  });
  describe('otherwise()', function() {
    describe('attaches a callback that will be called if this Promise is rejected', function() {
      describe('with parameters specified via function arguments', function() {
        specify('called if rejected', function(done) {
          var error, onRejected, promise;
          onRejected = sinon.spy();
          error = new Error('error message');
          promise = Deft.Deferred.reject(error);
          promise.otherwise(onRejected);
          promise.then(null, function() {
            try {
              expect(onRejected).to.be.calledOnce.and.calledWith(error);
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called in specified scope if rejected', function(done) {
          var error, onRejected, promise, targetScope;
          targetScope = {};
          onRejected = sinon.spy();
          error = new Error('error message');
          promise = Deft.Deferred.reject(error);
          promise.otherwise(onRejected, targetScope);
          promise.then(null, function() {
            try {
              expect(onRejected).to.be.calledOnce.and.calledWith(error).and.calledOn(targetScope);
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('not called if resolved', function(done) {
          var onRejected, promise;
          onRejected = sinon.spy();
          promise = Deft.Deferred.resolve('value');
          promise.otherwise(onRejected);
          promise.then(function() {
            var error;
            try {
              expect(onRejected).not.to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
      });
      describe('with parameters specified via a configuration object', function() {
        specify('called if rejected', function(done) {
          var error, onRejected, promise;
          onRejected = sinon.spy();
          error = new Error('error message');
          promise = Deft.Deferred.reject(error);
          promise.otherwise({
            fn: onRejected
          });
          promise.then(null, function() {
            try {
              expect(onRejected).to.be.calledOnce.and.calledWith(error);
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called in specified scope if rejected', function(done) {
          var error, onRejected, promise, targetScope;
          targetScope = {};
          onRejected = sinon.spy();
          error = new Error('error message');
          promise = Deft.Deferred.reject(error);
          promise.otherwise({
            fn: onRejected,
            scope: targetScope
          });
          promise.then(null, function() {
            try {
              expect(onRejected).to.be.calledOnce.and.calledWith(error).and.calledOn(targetScope);
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('not called if resolved', function(done) {
          var onRejected, promise;
          onRejected = sinon.spy();
          promise = Deft.Deferred.resolve('value');
          promise.otherwise({
            fn: onRejected
          });
          promise.then(function() {
            var error;
            try {
              expect(onRejected).not.to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
      });
    });
    describe('returns a Promise of the transformed future value', function() {
      specify('resolves with the returned value if callback returns a value', function() {
        var onRejected, promise;
        onRejected = function() {
          return 'returned value';
        };
        promise = Deft.Deferred.reject(new Error('error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('returned value');
      });
      specify('resolves with the resolved value if callback returns a Promise that resolves with value', function() {
        var onRejected, promise;
        onRejected = function() {
          return Deft.Deferred.resolve('resolved value');
        };
        promise = Deft.Deferred.reject(new Error('error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('rejects with the thrown Error if callback throws an Error', function() {
        var onRejected, promise;
        onRejected = function() {
          throw new Error('thrown error message');
        };
        promise = Deft.Deferred.reject(new Error('error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'thrown error message');
      });
      specify('rejects with the rejection reason if callback returns a Promise that rejects with a reason', function() {
        var onRejected, promise;
        onRejected = function() {
          return Deft.Deferred.reject(new Error('rejection reason'));
        };
        promise = Deft.Deferred.reject(new Error('original error message')).otherwise(onRejected);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
    });
  });
  describe('always()', function() {
    describe('attaches a callback to this Promise that will be called when it resolves or rejects', function() {
      describe('with parameters specified via function arguments', function() {
        specify('called with no parameters when resolved', function(done) {
          var onComplete, promise;
          onComplete = sinon.spy();
          promise = Deft.Deferred.resolve('value');
          promise.always(onComplete);
          promise.then(function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called with no parameters in the specified scope when resolved', function(done) {
          var onComplete, promise, targetScope;
          targetScope = {};
          onComplete = sinon.spy();
          promise = Deft.Deferred.resolve('value');
          promise.always(onComplete, targetScope);
          promise.then(function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called with no parameters when rejected', function(done) {
          var onComplete, promise;
          onComplete = sinon.spy();
          promise = Deft.Deferred.reject(new Error('error message'));
          promise.always(onComplete);
          promise.then(null, function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called with no parameters in the specified scope when rejected', function(done) {
          var onComplete, promise, targetScope;
          targetScope = {};
          onComplete = sinon.spy();
          promise = Deft.Deferred.reject(new Error('error message'));
          promise.always(onComplete, targetScope);
          promise.then(null, function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
      });
      describe('with parameters specified via a configuration object', function() {
        specify('called with no parameters when resolved', function(done) {
          var onComplete, promise;
          onComplete = sinon.spy();
          promise = Deft.Deferred.resolve('value');
          promise.always({
            fn: onComplete
          });
          promise.then(function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called with no parameters in the specified scope when resolved', function(done) {
          var onComplete, promise, targetScope;
          targetScope = {};
          onComplete = sinon.spy();
          promise = Deft.Deferred.resolve('value');
          promise.always({
            fn: onComplete,
            scope: targetScope
          });
          promise.then(function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called with no parameters when rejected', function(done) {
          var onComplete, promise;
          onComplete = sinon.spy();
          promise = Deft.Deferred.reject(new Error('error message'));
          promise.always({
            fn: onComplete
          });
          promise.then(null, function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
        specify('called with no parameters in the specified scope when rejected', function(done) {
          var onComplete, promise, targetScope;
          targetScope = {};
          onComplete = sinon.spy();
          promise = Deft.Deferred.reject(new Error('error message'));
          promise.always({
            fn: onComplete,
            scope: targetScope
          });
          promise.then(null, function() {
            var error;
            try {
              expect(onComplete).to.be.called;
              return done();
            } catch (_error) {
              error = _error;
              return done(error);
            }
          });
        });
      });
    });
    describe('return a new "pass-through" Promise that resolves with the original value or rejects with the original reason', function() {
      specify('if the originating Promise resolves, ignores value returned by callback', function() {
        var onComplete, promise;
        onComplete = function() {
          return 'callback return value';
        };
        promise = Deft.Deferred.resolve('resolved value').always(onComplete);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('if the originating Promise resolves, ignores and later rethrows Error thrown by callback', function(done) {
        var onComplete, promise;
        onComplete = function() {
          throw new Error('callback error message');
        };
        promise = Deft.Deferred.resolve('resolved value').always(onComplete);
        assert.eventuallyThrows(new Error('callback error message'), function(error) {
          if (error) {
            throw error;
          }
          return promise.should.eventually.equal('resolved value').then(function(value) {
            return done();
          }, function(reason) {
            return done(reason);
          });
        }, 100);
        promise.should.be.an["instanceof"](Deft.Promise);
      });
      specify('if the originating Promise rejects, ignores value returned by callback', function() {
        var onComplete, promise;
        onComplete = function() {
          return 'callback return value';
        };
        promise = Deft.Deferred.reject(new Error('rejection reason')).always(onComplete);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
      specify('if the originating Promise rejects, ignores and later rethrows Error thrown by callback', function(done) {
        var onComplete, promise;
        onComplete = function() {
          throw new Error('callback error message');
        };
        promise = Deft.Deferred.reject(new Error('rejection reason')).always(onComplete);
        assert.eventuallyThrows(new Error('callback error message'), function(error) {
          if (error) {
            throw error;
          }
          return promise.should.be.rejected["with"](Error, 'rejection reason').then(function(value) {
            return done();
          }, function(reason) {
            return done(reason);
          });
        }, 100);
        promise.should.be.an["instanceof"](Deft.Promise);
      });
    });
  });
  describe('done()', function() {
    describe('terminates a Promise chain, ensuring that unhandled rejections will be thrown as Errors', function() {
      specify('rethrows the rejection as an error if the originating Promise rejects', function(done) {
        var promise;
        this.slow(250);
        promise = Deft.Deferred.reject(new Error('rejection reason')).done();
        assert.eventuallyThrows(new Error('rejection reason'), done, 100);
      });
      specify('rethrows the rejection as an error if an ancestor Promise rejects and that rejection is unhandled', function(done) {
        var promise;
        this.slow(250);
        promise = Deft.Deferred.reject(new Error('rejection reason')).then(function(value) {
          return value;
        }).done();
        assert.eventuallyThrows(new Error('rejection reason'), done, 100);
      });
    });
  });
  describe('cancel()', function() {
    describe('cancels a Promise if it is still pending, triggering a rejection with a CancellationError that will propagate to any Promises originating from that Promise', function() {
      specify('rejects a pending Promise with a CancellationError', function() {
        var promise;
        promise = Ext.create('Deft.Deferred').promise;
        promise.cancel();
        return promise.should.be.rejected["with"](CancellationError);
      });
      specify('rejects a pending Promise with a CancellationError with a reason', function() {
        var promise;
        promise = Ext.create('Deft.Deferred').promise;
        promise.cancel('cancellation reason');
        return promise.should.be.rejected["with"](CancellationError, 'cancellation reason');
      });
      specify('ignores attempts to cancel a fulfilled Promise', function() {
        var promise;
        promise = Deft.Deferred.resolve('resolved value');
        promise.cancel();
        return promise.should.eventually.equal('resolved value');
      });
      specify('ignores attempts to cancel a rejected Promise', function() {
        var promise;
        promise = Deft.Deferred.reject(new Error('rejection reason'));
        promise.cancel();
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
      specify('propagates rejection with that CancellationError to Promises that originate from the cancelled Promise', function() {
        var promise;
        promise = Ext.create('Deft.Deferred').promise;
        promise.cancel('cancellation reason');
        return promise.then().should.be.rejected["with"](CancellationError, 'cancellation reason');
      });
    });
  });
  return describe('log()', function() {
    describe('logs the resolution or rejection of this Promise using Deft.Logger.log()', function() {
      beforeEach(function() {
        return sinon.spy(Deft.Logger, 'log');
      });
      afterEach(function() {
        return Deft.Logger.log.restore();
      });
      specify('logs a fulfilled promise', function(done) {
        var promise, value;
        value = 'resolved value';
        promise = Deft.Deferred.resolve(value).log();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;
          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Promise resolved with value: " + value);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
      specify('logs a fulfilled promise, with the optional name specified', function(done) {
        var promise, value;
        value = 'resolved value';
        promise = Deft.Deferred.resolve(value).log('Test Promise');
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;
          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Test Promise resolved with value: " + value);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
      specify('logs a rejected promise', function(done) {
        var promise, reason;
        reason = new Error('rejection reason');
        promise = Deft.Deferred.reject(reason).log();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;
          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Promise rejected with reason: " + reason);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
      specify('logs a rejected promise, with the optional name specified', function(done) {
        var promise, reason;
        reason = new Error('rejection reason');
        promise = Deft.Deferred.reject(reason).log('Test Promise');
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.always(function() {
          var error;
          try {
            expect(Deft.Logger.log).to.be.calledOnce.and.calledWith("Test Promise rejected with reason: " + reason);
            done();
          } catch (_error) {
            error = _error;
            done(error);
          }
        });
      });
    });
    describe('return a new "pass-through" Promise that resolves with the original value or rejects with the original reason', function() {
      specify('resolves if the originating Promise resolves', function() {
        var promise;
        promise = Deft.Deferred.resolve('resolved value').log();
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('resolved value');
      });
      specify('rejects if the originating Promise rejects', function() {
        var promise;
        promise = Deft.Deferred.reject(new Error('rejection reason')).log();
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'rejection reason');
      });
    });
  });
});
