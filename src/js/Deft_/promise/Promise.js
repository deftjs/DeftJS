// Generated by CoffeeScript 1.4.0
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).

Promise.when(), all(), any(), some(), map() and reduce() methods adapted from:
[when.js](https://github.com/cujojs/when)
Copyright (c) B Cavalier & J Hann
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/**
* A Promise represents the result of a future value that has not been defined yet, typically because it is created asynchronously. Used in conjunction with Deft.promise.Deferred.
*/

Ext.define('Deft.promise.Promise', {
  alternateClassName: ['Deft.Promise'],
  statics: {
    /**
    		* Returns a new {@link Deft.promise.Promise} that:
    		* - resolves immediately for the specified value, or
    		* - resolves, rejects, updates or cancels when the specified {@link Deft.promise.Deferred} or {@link Deft.promise.Promise} is resolved, rejected, updated or cancelled.
    */

    when: function(promiseOrValue) {
      var deferred;
      if (promiseOrValue instanceof Ext.ClassManager.get('Deft.promise.Promise') || promiseOrValue instanceof Ext.ClassManager.get('Deft.promise.Deferred')) {
        return promiseOrValue.then();
      } else if (Ext.isObject(promiseOrValue) && Ext.isFunction(promiseOrValue.then)) {
        deferred = Ext.create('Deft.promise.Deferred');
        promiseOrValue.then(function(value) {
          deferred.resolve(value);
        }, function(error) {
          deferred.reject(error);
        });
        return deferred.then();
      } else {
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.resolve(promiseOrValue);
        return deferred.then();
      }
    },
    /**
    		* Returns a new {@link Deft.promise.Promise} that will only resolve once all the specified `promisesOrValues` have resolved.
    		* The resolution value will be an Array containing the resolution value of each of the `promisesOrValues`.
    */

    all: function(promisesOrValues) {
      return this.when(promisesOrValues).then({
        success: function(promisesOrValues) {
          var cancelFunction, canceller, complete, createSuccessFunction, deferred, failureFunction, index, progressFunction, promiseOrValue, rejecter, resolvedCount, resolvedValues, resolver, total, updater, _i, _len;
          deferred = Ext.create('Deft.promise.Deferred');
          total = promisesOrValues.length;
          resolvedValues = new Array(promisesOrValues);
          resolvedCount = 0;
          updater = function(progress) {
            deferred.update(progress);
            return progress;
          };
          resolver = function(index, value) {
            resolvedValues[index] = value;
            resolvedCount++;
            if (resolvedCount === total) {
              complete();
              deferred.resolve(resolvedValues);
            }
            return value;
          };
          rejecter = function(error) {
            complete();
            deferred.reject(error);
            return error;
          };
          canceller = function(reason) {
            complete();
            deferred.cancel(reason);
            return reason;
          };
          complete = function() {
            return updater = resolver = rejecter = canceller = Ext.emptyFn;
          };
          createSuccessFunction = function(index) {
            return function(value) {
              return resolver(index, value);
            };
          };
          failureFunction = function(value) {
            return rejecter(value);
          };
          progressFunction = function(value) {
            return updater(value);
          };
          cancelFunction = function(value) {
            return canceller(value);
          };
          for (index = _i = 0, _len = promisesOrValues.length; _i < _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              this.when(promiseOrValue).then({
                success: createSuccessFunction(index),
                failure: failureFunction,
                progress: progressFunction,
                cancel: cancelFunction
              });
            }
          }
          return deferred.getPromise();
        },
        scope: this
      });
    },
    /**
    		* Initiates a competitive race, returning a new {@link Deft.promise.Promise} that will resolve when any one of the supplied `promisesOrValues`
    		* have resolved, or will reject when all `promisesOrValues` have rejected or cancelled.
    		* The resolution value will the first value of `promisesOrValues` to resolve.
    */

    any: function(promisesOrValues) {
      return this.some(promisesOrValues, 1).then({
        success: function(values) {
          return values[0];
        }
      });
    },
    /**
    		* Initiates a competitive race, returning a new {@link Deft.promise.Promise} that will resolve when `howMany` of the supplied `promisesOrValues`
    		* have resolved, or will reject when it becomes impossible for `howMany` to resolve.
    		* The resolution value will be an Array of the first `howMany` values of `promisesOrValues` to resolve.
    */

    some: function(promisesOrValues, howMany) {
      return this.when(promisesOrValues).then({
        success: function(promisesOrValues) {
          var cancelFunction, canceller, complete, deferred, errorMessage, failureFunction, index, progressFunction, promiseOrValue, rejecter, remainingToReject, remainingToResolve, resolver, successFunction, updater, values, _i, _len;
          values = [];
          remainingToResolve = howMany;
          remainingToReject = (promisesOrValues.length - remainingToResolve) + 1;
          deferred = Ext.create('Deft.promise.Deferred');
          if (promisesOrValues.length < howMany) {
            deferred.reject(new Error('Too few Promises or values were supplied to obtain the requested number of resolved values.'));
          } else {
            errorMessage = howMany === 1 ? 'No Promises were resolved.' : 'Too few Promises were resolved.';
            updater = function(progress) {
              deferred.update(progress);
              return progress;
            };
            resolver = function(value) {
              values.push(value);
              remainingToResolve--;
              if (remainingToResolve === 0) {
                complete();
                deferred.resolve(values);
              }
              return value;
            };
            rejecter = function(error) {
              remainingToReject--;
              if (remainingToReject === 0) {
                complete();
                deferred.reject(new Error(errorMessage));
              }
              return error;
            };
            canceller = function(reason) {
              remainingToReject--;
              if (remainingToReject === 0) {
                complete();
                deferred.reject(new Error(errorMessage));
              }
              return reason;
            };
            complete = function() {
              return updater = resolver = rejecter = canceller = Ext.emptyFn;
            };
            successFunction = function(value) {
              return resolver(value);
            };
            failureFunction = function(value) {
              return rejecter(value);
            };
            progressFunction = function(value) {
              return updater(value);
            };
            cancelFunction = function(value) {
              return canceller(value);
            };
            for (index = _i = 0, _len = promisesOrValues.length; _i < _len; index = ++_i) {
              promiseOrValue = promisesOrValues[index];
              if (index in promisesOrValues) {
                this.when(promiseOrValue).then({
                  success: successFunction,
                  failure: failureFunction,
                  progress: progressFunction,
                  cancel: cancelFunction
                });
              }
            }
          }
          return deferred.getPromise();
        },
        scope: this
      });
    },
    /**
    		* Returns a new function that wraps the specified function and caches the results for previously processed inputs.
    		* Similar to `Deft.util.Function::memoize()`, except it allows input to contain promises and/or values.
    */

    memoize: function(fn, scope, hashFn) {
      var memoizedFn;
      memoizedFn = Deft.util.Function.memoize(fn, scope, hashFn);
      return Ext.bind(function() {
        return this.all(Ext.Array.toArray(arguments)).then(function(values) {
          return memoizedFn.apply(scope, values);
        });
      }, this);
    },
    /**
    		* Traditional map function, similar to `Array.prototype.map()`, that allows input to contain promises and/or values.
    		* The specified map function may return either a value or a promise.
    */

    map: function(promisesOrValues, mapFunction) {
      var createCallback;
      createCallback = function(index) {
        return function(value) {
          return mapFunction(value, index, promisesOrValues);
        };
      };
      return this.when(promisesOrValues).then({
        success: function(promisesOrValues) {
          var index, promiseOrValue, results, _i, _len;
          results = new Array(promisesOrValues.length);
          for (index = _i = 0, _len = promisesOrValues.length; _i < _len; index = ++_i) {
            promiseOrValue = promisesOrValues[index];
            if (index in promisesOrValues) {
              results[index] = this.when(promiseOrValue).then(createCallback(index));
            }
          }
          return this.reduce(results, this.reduceIntoArray, results);
        },
        scope: this
      });
    },
    /**
    		* Traditional reduce function, similar to `Array.reduce()`, that allows input to contain promises and/or values.
    */

    reduce: function(promisesOrValues, reduceFunction, initialValue) {
      var initialValueSpecified;
      initialValueSpecified = arguments.length === 3;
      return this.when(promisesOrValues).then({
        success: function(promisesOrValues) {
          var reduceArguments, whenFunction;
          whenFunction = this.when;
          reduceArguments = [
            function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
              return whenFunction(previousValueOrPromise).then(function(previousValue) {
                return whenFunction(currentValueOrPromise).then(function(currentValue) {
                  return reduceFunction(previousValue, currentValue, currentIndex, promisesOrValues);
                });
              });
            }
          ];
          if (initialValueSpecified) {
            reduceArguments.push(initialValue);
          }
          return this.when(this.reduceArray.apply(promisesOrValues, reduceArguments));
        },
        scope: this
      });
    },
    /**
    		* Fallback implementation when Array.reduce is not available.
    		* @private
    */

    reduceArray: function(reduceFunction, initialValue) {
      var args, array, index, length, reduced;
      index = 0;
      array = Object(this);
      length = array.length >>> 0;
      args = arguments;
      if (args.length <= 1) {
        while (true) {
          if (index in array) {
            reduced = array[index++];
            break;
          }
          if (++index >= length) {
            throw new TypeError();
          }
        }
      } else {
        reduced = args[1];
      }
      while (index < length) {
        if (index in array) {
          reduced = reduceFunction(reduced, array[index], index, array);
        }
        index++;
      }
      return reduced;
    },
    /**
    		* @private
    */

    reduceIntoArray: function(previousValue, currentValue, currentIndex) {
      previousValue[currentIndex] = currentValue;
      return previousValue;
    }
  },
  id: null,
  constructor: function(config) {
    this.id = config.id;
    this.deferred = config.deferred;
    return this;
  },
  /**
  	* Returns a new {@link Deft.promise.Promise} with the specified callbacks registered to be called when this {@link Deft.promise.Promise} is resolved, rejected, updated or cancelled.
  */

  then: function(callbacks) {
    return this.deferred.then.apply(this.deferred, arguments);
  },
  /**
  	* Returns a new {@link Deft.promise.Promise} with the specified callback registered to be called when this {@link Deft.promise.Promise} is rejected.
  */

  otherwise: function(callback, scope) {
    return this.deferred.otherwise.apply(this.deferred, arguments);
  },
  /**
  	* Returns a new {@link Deft.promise.Promise} with the specified callback registered to be called when this {@link Deft.promise.Promise} is resolved, rejected or cancelled.
  */

  always: function(callback, scope) {
    return this.deferred.always.apply(this.deferred, arguments);
  },
  /**
  	* Cancel this {@link Deft.promise.Promise} and notify relevant callbacks.
  */

  cancel: function(reason) {
    return this.deferred.cancel(reason);
  },
  /**
  	* Get this {@link Deft.promise.Promise}'s current state.
  */

  getState: function() {
    return this.deferred.getState();
  },
  /**
  	* Returns a text representation of this {@link Deft.promise.Promise}, including its optional id.
  */

  toString: function() {
    if (this.id != null) {
      return "Promise " + this.id;
    }
    return "Promise";
  }
}, function() {
  if (Array.prototype.reduce != null) {
    this.reduceArray = Array.prototype.reduce;
  }
});
